---
title: "[알고리즘] 깊이우선탐색(DFS)"
excerpt: "알고리즘: 깊이우선탐색(DFS)에 대한 공부 노트"
toc: true
toc_sticky: true
toc_label: "주요 목차"
header:
  teaser: /assets/images/header_teaser.jpg

date: 2022-01-14T12:19:35+09:00

categories:
  - Playdata Algo

tags:
  - 알고리즘
  - Algorithm
  - DFS
  - Depth First Search
  - 스택
  - Stack
  - 깊이우선탐색
  - 자료구조
  - 코딩테스트
  - Programming
  - 프로그래밍
  - Python
  - 파이썬

last_modified_at: 2022-01-14T12:19:35+09:00
---

# **깊이우선탐색(DFS)**

<div class="notice">
    <h4>
        🔊 2021.04.08 (목) 엔코아 플레이데이터 알고리즘 특강 3주차 내용을 정리한 노트 게시물입니다.
    </h4>
</div>

## PART 1. 깊이우선탐색(DFS)

### 깊이우선탐색(DFS)란?

Depth First Search의 약자로 넓이 우선 탐색을 의미<BR>하나의 경우의 수에 대하여 모든 경우의 수를 조사하고 다음 경우의 수를 조사하면서 해를 찾는 과정

### 깊이우선탐색(DFS)의 구조

![image](https://user-images.githubusercontent.com/78403443/149431267-c0888e2b-905e-4201-9580-4a8c7479beec.png)

여기 하나의 트리구조가 있다고 생각해보자.

그럼 시작점인 A에서부터 정답을 찾아가는 과정을 살펴보도록 하자.<br>먼저 A가 정답인지 아닌지를 검사한다. 정답이 아니므로 우리는 A 아래에 있는 B, C, D를 검사해야하는데 우선 B부터 검사하도록 한다.<br>B도 정답이 아니다. 그러면 이제 C를 검사하면 될까? 아니다.<BR>깊이우선탐색은 일단 B를 끝까지 파헤쳐보는 것이다. B 아래에 E, F가 존재한다.<BR>우리는 E부터 검사한다. E도 정답이 아니다. 그러면 F로 넘어갈까? 아니다.<BR>E 아래를 끝까지 조사해야한다. 그래서 J를 검사한다. J는 정답이 아니면서 더 이상 아래에 자식이 존재하지 않는다. 그렇기 때문에 J는 여기서 탈락하게 되고, 다시 돌아나가서 F를 확인해보도록 한다. F 역시 정답이 아니다.<BR>그럼, F 아래에는 K와 L이 있는데 K부터 검사해보도록 한다. 하지만, K도 역시 정답이 아니고 탈락.<BR>L도 검사해보자. 하지만, 역시 정답이 아니므로 탈락한다. 우리는 이렇게 B의 검사가 모두 끝났다.<BR>이제는 C를 검사해보도록 한다. C는 정답이 아니기 때문에 C 아래 G를 검사해본다. G도 정답이 아니다. G 아래를 검사해보도록 한다. 정답이다.

![image](https://user-images.githubusercontent.com/78403443/149433781-2afcb770-a2df-4282-a47d-3caafd01a868.png)

우리는 정답을 발견했으므로 알고리즘을 여기서 종료하면 될 것이다.

여기까지가 깊이우선탐색의 기본구조였다.

### 스택의 활용

![image](https://user-images.githubusercontent.com/78403443/114008758-8430a500-989d-11eb-935f-393dc70b55bd.png)

지난 스택과 큐 강의에서 깊이우선탐색을 스택의 활용 예시로 말했었는데 그럼 이 개념을 어떻게 깊이우선탐색에 적용시킬 수 있는지 그 로직을 살펴보도록 한다.

### 깊이우선탐색(DFS)과 스택

![image](https://user-images.githubusercontent.com/78403443/149434422-9708ccbc-ab8b-419d-9b35-5a653cdcd849.png)

우선 우리가 탐색해야할 트리가 여기 있다. 한쪽 방향에서만 접근이 가능한 스택도 있다. 그리고, 정답인지 아닌지 판단할 조건문을 하나 만들어두도록 한다.

![image](https://user-images.githubusercontent.com/78403443/149434552-79c02e66-bf07-4444-bc60-11a192d486cf.png)

시작점은 A 이므로 A부터 검사하도록 하겠다. A는 정답이 아니므로 A 아래 가능한 경우의 수를 모두 스택에 담도록 한다. B, C, D가 담긴 것을 우리는 볼 수 있다.<BR>그리고, A는 검사가 끝났다. 그럼 스택에서 우리는 가장 위에있는 B를 꺼내서 검사하도록 한다.

![image](https://user-images.githubusercontent.com/78403443/149434768-4b478874-bfe5-4100-9dfb-ce033d6d0701.png)

하지만, B는 정답이 아니므로 B 아래에 존재하는 경우의 수 E와 F를 스택에 추가한다. 

![image](https://user-images.githubusercontent.com/78403443/149435110-db23439d-23fd-49ef-8482-0b9333a930ae.png)

그리고 B를 검사를 종료한다.

![image](https://user-images.githubusercontent.com/78403443/149434938-aae31be9-2621-4bec-9b86-9351e41da0a1.png)

![image](https://user-images.githubusercontent.com/78403443/149435180-40161ff8-c63c-4ba9-942f-7187d10469da.png)

검사가 종료되었다면 스택에서 가장 위에 있는 E를 꺼내와서 검사하도록 한다. 하지만, E역시 정답이 아니므로 E 아래 존재하는 J를 스택에 추가해준다. 그리고, E는 검사를 종료한다.

![image](https://user-images.githubusercontent.com/78403443/149435274-ff461911-6aac-4906-95cd-fc09178e88bf.png)

![image](https://user-images.githubusercontent.com/78403443/149435549-3a4e21d6-efbe-4780-89b1-41789a139047.png)

다시 스택에서 가장 위에있는 J를 꺼내와서 검사하도록 한다. 하지만, J 역시 정답이 아니고,  J 아래에 존재하는 경우의 수가 더 이상 존재하지 않기 때문에 스택에 추가할 것이 없다. 

![image](https://user-images.githubusercontent.com/78403443/149435618-03ba7136-05b2-4cbc-afb6-451b51b7fa3e.png)

이렇게 해서, J는 검사가 끝났고, 다시 처음으로 돌아가서 스택에서 가장 위에 있는 F를 꺼내오도록 한다. F는 정답이 아니다. F는 정답이 아니므로 F 아래 존재하는 K와 L을 스택에 추가하도록 한다.

![image](https://user-images.githubusercontent.com/78403443/149435719-50b5c5f2-d07d-4d4c-86c6-1452df901d72.png)

그리고, F를 종료한다.

![image](https://user-images.githubusercontent.com/78403443/149436055-346f6187-82f0-417c-a5e8-1255b1dfae56.png)

다시 스택에 가장 위에 있는 데이터인 K를 꺼내와서 검사하도록 한다.

![image](https://user-images.githubusercontent.com/78403443/149435905-9f83308d-454e-40a7-b458-b113e3f7c7b1.png)

K는 정답이 아니면서 아래 경우의 수를 스택에 추가하려고 하지만 K 아래에는 더이상 추가할 데이터가 없기 때문에 검사를 여기서 종료하도록 한다.

![image](https://user-images.githubusercontent.com/78403443/149436260-abf6bda4-deef-4927-b6e1-1119551f6b2c.png)

이번엔 스택의 가장 위에 있는 데이터 L을 검사하도록 한다. L을 꺼내온다.

![image](https://user-images.githubusercontent.com/78403443/149436348-15da1b94-3294-412a-9564-00a646f248ba.png)

L 역시 정답이 아니고 아래 데이터가 더이상 존재하지 않기 때문에 스택에 추가할 것이 없다. 따라서, L의 검사는 여기서 종료하도록 한다.

![image](https://user-images.githubusercontent.com/78403443/149436433-5880d811-6658-4cec-a547-98729dc9a80a.png)

이렇게 우리는 B 아래에 있는 모든 경우의 수에 대한 탐색이 끝났다. 하지만, 정답을 찾지 못했다. 그렇지만, 여전히 스택 안에는 데이터가 존재하고 있기 때문에 스택을 계속해서 검사해주도록 한다. 이번엔 C를 검사해야되겠다.

![image](https://user-images.githubusercontent.com/78403443/149436649-5b321a8a-2481-4817-a5e4-df4ce28a3a3a.png)

C를 검사한다. C는 정답이 아니다. 그래서 C 아래에 있는 데이터 G를 스택에 추가하도록 한다. 그리고 C는 검사를 종료한다.

![image](https://user-images.githubusercontent.com/78403443/149436807-e41bf5bf-d829-42f9-95a0-b8c8fcfa7cdf.png)

스택에서 가장 위에 있는 데이터 G를 꺼내서 검사하도록 한다.

![image](https://user-images.githubusercontent.com/78403443/149436885-f9d42718-acd1-4c4c-b67e-9b2efd6159cc.png)

G 역시 정답이 아니므로 G 아래의 데이터를 추가해주도록 한다. 그리고 G를 종료한다.

![image](https://user-images.githubusercontent.com/78403443/149436952-9bdfd816-09ef-4de6-b77f-872523961cbe.png)

스택에서 가장 위에 있는 데이터 불러온다. 

![image](https://user-images.githubusercontent.com/78403443/149437105-33c70dfd-4339-4577-9dab-e38a11f21ce4.png)

그리고 검사했더니 우리가 원하던 정답이다. 따라서 여기서 우리는 알고리즘을 종료하면 될 것이다. 

![image](https://user-images.githubusercontent.com/78403443/149437199-909a8d4a-2b1e-4fa9-9ac2-868ae81e0c08.png)

여기까지 깊이우선탐색과 스택을 어떻게 같이 사용할 수 있는지 알아보았다. 그러나, 어떤 문제에서 어떻게 활용할 수 있을지 감이 오지 않을 것이다. 그래서, 예시문제를 하나 보면서 실전감각을 키울 수 있도록 한다.

### 깊이우선탐색(DFS) 구현

#### 미로찾기

깊이우선탐색의 가장 대표적인 문제로는 미로찾기가 있다.<BR>아래와 같은 미로를 깊이우선탐색과 스택을 활용해서 같이 풀어나가보도록 한다.

![image](https://user-images.githubusercontent.com/78403443/149437429-3720e730-2d8d-4600-8d6b-70f7bfac19b4.png)

문제를 보면 위와 같다.<BR>먼저, 미로를 지날 수 있는 길을 0, 지날 수 없는 길을 1로 표현해보도록 한다.

![image](https://user-images.githubusercontent.com/78403443/149437700-29a5d2ff-3643-4018-97c5-4b94431d97e7.png)

그리고, 문제를 풀기 위해서 편의상 인덱스도 쉽게 볼 수 있도록 나타내도록 한다.<BR>그럼, 이 문제를 풀기 위해 우리는 스택을 선언해줘야 된다. 그래서 스택을 하나 선언해준다. 그리고 정답인지 아닌지를 검사할 수 있도록 조건문도 하나 추가해주도록 한다.

![image](https://user-images.githubusercontent.com/78403443/149437946-f0fd0dce-d42c-42cb-908d-af6c61df0a2e.png)

처음에 시작점이 [0,0] 부터 검사를 시작하도록 한다. 

![image](https://user-images.githubusercontent.com/78403443/149438497-1135183c-8f8a-47cc-bf12-53346f7609a8.png)

[0,0]의 좌표는 도착지점이 아니므로 [0,0]에서 이동할 수 있는 곳은 오른쪽으로 가는 [0,1] 한 군데 밖에 없다. 따라서 이동 가능한 곳의 좌표 [0,1]을 스택에 담아주도록 한다. 그리고, [0,0]의 검사를 종료하도록 한다.

![image](https://user-images.githubusercontent.com/78403443/149438662-32655744-4a4a-4d23-90c9-df2b5fc8c174.png)

스택에는 지금 데이터가 남아있기 때문에 우리는 계속해서 검사를 진행해야한다. 스택에서 가장 마지막에 있는 데이터 [0,1]을 꺼내와 검사하도록 한다.

![image](https://user-images.githubusercontent.com/78403443/149438833-aebec99a-c1bf-4a21-8f69-4ff4f6eba8bf.png)

[0,1]은 정답이 아니므로 [0,1]에서 움직일 수 있는 곳을 스택에 담아주도록 한다. [0,1]에서 바로 움직일 수 있는 곳인 [0,2]와 [1,1] 두 군데를 담아주도록 한다. 그리고 [0,1]을 종료한다.

![image](https://user-images.githubusercontent.com/78403443/149439025-d932588b-8fd9-4725-90a4-4f7a355156d1.png)

현재 스택에서 가장 위에 있는 데이터인 [0,2]부터 꺼내서 검사해보도록 한다.

![image](https://user-images.githubusercontent.com/78403443/149439105-85579578-087e-4b0c-b708-59a36d47eab8.png)

[0,2] 역시 도착지점이 아니므로 [0,2]에서 오른쪽으로 한 칸 움직인 [0,3]을 스택에 담고 검사를 종료한다.

![image](https://user-images.githubusercontent.com/78403443/149439271-79a9909a-1741-4908-b427-1df52a83f7b3.png)

다시 스택에서 데이터를 꺼내온다.

![image](https://user-images.githubusercontent.com/78403443/149439330-504bcfc6-7659-4b98-871c-f922bc0097b2.png)

검사를 하지만 [0,3]은 정답이 아니므로 [0,3]에서 이동가능한 [0,4]의 좌표를 스택에 담고 종료한다.

![image](https://user-images.githubusercontent.com/78403443/149439421-db3852a2-41e9-4a52-be0b-5cc10b97ad14.png)

다시 [0,4]를 스택에서 꺼내온다. 

![image](https://user-images.githubusercontent.com/78403443/149439632-986ff18f-af2c-4da5-b2bf-55e9071e8080.png)

마찬가지로 정답은 아니고 오른쪽으로 갈 수 있는 [0,5]를 스택에 담아주도록 한다. 그리고 [0,4]의 검사를 종료한다.

![image](https://user-images.githubusercontent.com/78403443/149439680-7941dd9f-5d35-41a1-9534-83bb8f96dfa5.png)

다시 스택에 마지막으로 들어간 데이터인 [0,5]를 꺼내서 검사한다.

![image](https://user-images.githubusercontent.com/78403443/149440017-348cc97b-0b97-4809-9928-ba1b7f724dd4.png)

도착지점이 아니므로 이동할 수 있는 아래 방향으로 갈 수 있는 [1,5]를 스택에 담고 종료한다.

![image](https://user-images.githubusercontent.com/78403443/149440112-9d740afa-ad0a-4f33-bf12-a5d447af7274.png)

스택에서 마지막에 있는 데이터 [1,5]를 검사하지만 마찬가지로 정답이 아님. 아래로 가는 [2,5]를 스택에 담고 검사를 종료한다.

![image](https://user-images.githubusercontent.com/78403443/149440748-55fd6cf1-3926-404a-a22e-aaeacef7e341.png)

스택에서 마지막에 있는 데이터 [2,5] 다시 꺼내와서 검사하도록 한다.

![image](https://user-images.githubusercontent.com/78403443/149440819-a04d6022-807a-44ad-939c-94127965f5ce.png)

이번에도 아래로 갈 수 있는 [3,5]를 스택에 담아주고 종료한다.

![image](https://user-images.githubusercontent.com/78403443/149440942-2b5119ab-d312-4518-a594-f7d071b3afc9.png)

다시 [3,5]를 스택에서 꺼내온다. 검사를 하고 정답이 아니므로 [3,5]에서 갈 수 있는 위치를 검색해서 [3,4]를 스택에 담아주도록 한다. 그리고, 검사를 종료한다.

![image](https://user-images.githubusercontent.com/78403443/149441053-3aff5214-a05c-4087-a510-4537bd7f8a98.png)

다시 스택의 가장 마지막에 있는 데이터 [3,4]를 꺼내서 검사한다.

![image](https://user-images.githubusercontent.com/78403443/149441134-7a2de5bd-db05-4856-a101-462ad027b9cb.png)

[3,4]에서는 현재 왼쪽으로 갈 수 있다. 따라서, [3,3]을 스택에 담아주고 검사를 종료하도록 한다.

![image](https://user-images.githubusercontent.com/78403443/149441262-4f844e22-9339-4142-a4e7-a7cd6520cca0.png)

다시 스택에서 제일 위에 있는 데이터를 꺼내주도록 한다. 

![image](https://user-images.githubusercontent.com/78403443/149441380-20179d55-b2d9-45d6-a05e-d1ad9b5ab090.png)

[3,3]에서 갈 수 있는 곳은 현재 [2,3] 밖에 없다. 그래서, [2,3]의 좌표를 스택에 담아주고 [3,3]을 종료한다.

![image](https://user-images.githubusercontent.com/78403443/149441439-4f13658a-9f6f-4150-814f-e6efcce2dace.png)

우리는 이 과정을 계속해서 반복해야한다.<BR>스택에서 제일 위에 있는 데이터 [2,3]을 꺼내온다.

![image](https://user-images.githubusercontent.com/78403443/149441520-1236a90e-4a5d-42f8-9cbb-483a4960a96c.png)

그리고 검사를 하는데 정답이 아니므로 [2,3]에서 갈 수 있는 곳의 좌표를 스택에 담고 종료해야되는데... [2,3]에서는 더이상 갈 수 있는 곳이 없다. 그래서, 스택에 아무것도 추가할 수 없다. 검사를 종료한다.

![image](https://user-images.githubusercontent.com/78403443/149441809-b1834fc9-fb78-4ba8-bf74-75827e1067b7.png)

하지만, 우리가 지금 정답을 찾은 것이 아니므로 우리는 검사를 계속해서 진행해야한다. 지금 스택의 가장 마지막에는 처음에 아까 담아두었던 [1,1]이 아직 남아있다.

다시 [1,1]로 돌아가서 검사를 계속 진행해보도록 한다.

![image](https://user-images.githubusercontent.com/78403443/149441960-1dd47026-e8e3-4c42-8dda-e566c1d76a33.png)

[1,1]을 꺼내서 검사를 하지만 정답은 아니고 아래로 이동할 수 있기 때문에, 아래로 가는 [2,1]의 좌표를 스택에 담는다. 그리고 [1,1]을 종료한다.

![image](https://user-images.githubusercontent.com/78403443/149442099-3c2e859c-2879-4fa9-95a3-22df297530a5.png)

스택의 마지막에서 다시 [2,1]을 꺼내서 검사하고 왼쪽으로 갈 수 있는 [2,0]을 담도록 한다.

![image](https://user-images.githubusercontent.com/78403443/149442188-402496dc-5bc4-43ed-9b06-fbb4eef335ee.png)

그리고, 종료한다.

![image](https://user-images.githubusercontent.com/78403443/149442240-6843f037-9bef-4c6e-975c-60ba309cd648.png)

여기까지의 로직을 보면 아마 알고리즘 진행이 어떻게 되는지 예상할 수 있을 것이기 때문에 진행과정만 간단하게 계속 본다. (여기서 진행과정 이미지는 생략...)

![image](https://user-images.githubusercontent.com/78403443/149442791-e373a524-50f4-47fd-9c06-ea69b559490b.png)

마지막! [5,5]에 도착지점에 도달하였을 때는 조건문에 의해서 True를 반환하고 알고리즘이 종료될 것이다.<br>만약, 도달하지 못했다면 스택이 먼저 데이터를 가지고 있지 않으면서 반복문에서 빠져나가 False를 반환하게 될 것이다. 미로찾기는 이것으로 끝이다.

지금까지의 과정을 코드로 구현하기는 분명 처음에는 쉽지 않다.<br>그리고, 이 과정을 코드로 적어 놓으려면 몇 주일 정도 걸릴 수도 있다.<br>한번 방금 예시의 전체 코드의 90% 정도 되는 핵심 부분만 발췌해서 같이 보도록 하자.

### 깊이우선탐색(DFS) 예시코드

#### 미로찾기

![image](https://user-images.githubusercontent.com/78403443/114010847-8693fe80-989f-11eb-83d6-8d3bfb776808.png)

```python
while len(stack) > 0: # 스택에 데이터가 있다면 계속해서 반복 실행하겠다
    now = stack.pop() # 스택에서 가장 위에 있는 데이터를 꺼내와 현재위치를 나타낼 now라는 변수에 담아준다.
    if now == dest: # now라고 하는 변수가 도착지점인지 아닌지를 검사한다.
        return True # 도착지점이라면 True를 반환
    
    # 여기부턴 방향 설정
    x = now[1] # x는 미로에서 x축으로 왼쪽방향 오른쪽방향을 나타내는 변수
    y = now[0]
    
    # x가 현재위치라면 x-1은 왼쪽방향인데 그 왼쪽방향으로 이동했을 때 인덱스 값을 벗어나면 안될 것이다. 
    # 따라서, "x-1이 -1보다 크다면" 이라는 조건으로 동작한다.
    if x-1 > -1: # (왼쪽방향)
        # 왼쪽으로의 인덱스 값이 벗어나지 않는다면, 갈 수 있는 길인지 아닌지를 확인하는 조건문 
        if maps[y][x-1] == 0:
            stack.append([y,x-1]) # 갈 수 있다면 스택에 담고,
            maps[y][x-1] = 2 # 기존의 지도에서 0 이었던 값을 2로 바꿈으로써 '방문하였다'고 표시
    
    # x+1은 오른쪽방향 마찬가지로 지도를 벗어나면 안되므로 
    # 인덱스가 맵의 크기를 벗어나는지 벗어나지 않는지 확인해준다.
    if x+1 < hori: # (오른쪽방향)
        # 왼쪽방향과 같은 구성
        if maps[y][x+1] == 1:
            stack.append([y,x+1])
            maps[y][x+1] = 2 # 방문했음을 표시안해주면 컴퓨터는 왼쪽, 오른쪽 왔다갔다하는 무한 루프에 빠질 수 있음
                             # 그러므로, 꼭 방문여부 체크!
    # (위쪽 방향)
    if y-1 > -1:
        if maps[y-1][x] == 1:
            stack.append([y-1,x])
            maps[y-1][x] = 2
    # (아래쪽 방향)
    if y+1 < verti:
        if maps[y+1][x] == 1:
            stack.append([y+1,x])
            maps[y+1][x] = 2

return False # 그러나, 이러한 과정을 거쳤음에도 미로를 탈출할 수 없다면
		    # 스택에 데이터가 없게 되어 while문을 빠져나가 False를 반환하게 될 것이다.
```

<div class="notice">
    <h4>
        🔊 ppt 캡쳐 이미지는 엔코아 플레이데이터 소유이므로, 무단 불펌하지 말아주세요!
    </h4>
</div>
[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}