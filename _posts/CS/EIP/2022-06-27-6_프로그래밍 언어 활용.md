---
title: "[정보처리기사(실기)] 6. 프로그래밍 언어 활용"
excerpt: "6. 프로그래밍 언어 활용"
toc: true
toc_sticky: true
toc_label: "주요 목차"
header:
  teaser: /assets/images/header_eip.jpg

date: 2022-06-27T19:57:13+09:00

categories:
  - OS

tags:
  - 정보처리기사
  - 정보처리기사 실기
  - 공부
  - 스터디
  - Study
  - Engineer Information Processing
  - 수제비
  - 프로그래밍 언어 활용
  - 기본 문법 활용하기
  - C
  - C언어
  - 진수
  - 변수
  - 배열
  - 포인터
  - 연산자
 
last_modified_at: 2022-06-27T19:57:13+09:00
---

<div class="notice">
    <h4>
        🔊 수제비 2022 정보처리기사 실기 교재로 공부하면서 스스로 좀 더 학습해야되고, 기억해야되는 부분을 개인적으로 정리한 내용입니다.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(저는 C를 아예 몰라서, C 코드에 대한 내용이 많습니다)
    </h4>
</div>

# Chapter 01. 기본 문법 활용하기

## 1️⃣ 프로그래밍을 위한 기본 사항

### (1) 진수

#### 1️⃣ 진수(Antilogarithm) 개념

- 특정 개수의 숫자만을 이용하여 수를 나타내는 수 체계이다.
- 10진수 이하일 때는 0~9를 사용하지만, 10진수 초과할 경우는 영어 알파벳을 이용한다.

| 10진수 | 16진수 |
| :----: | :----: |
|   0    |   0    |
|   1    |   1    |
|   2    |   2    |
|   3    |   3    |
|   4    |   4    |
|   5    |   5    |
|   6    |   6    |
|   7    |   7    |
|   8    |   8    |
|   9    |   9    |
|   10   |   A    |
|   11   |   B    |
|   12   |   C    |
|   13   |   D    |
|   14   |   E    |
|   15   |   F    |

#### 2️⃣ 진수 변환

- ① 10진수를 n진수로 변환
  - 10진수 값을 몫이 n보다 작을 때까지 n으로 나누고 나머지 값들을 표시한 후에 나머지 값들을 읽는다. (교재 예제보기)
- ② n진수를 10진수로 변환
  - n진수에서 마지막 자리는 자리 숫자에 자릿값인 n<sup>0</sup>을 곱하고, 마지막에서 두 번째 자리 숫자에 자릿값인 n<sup>1</sup>을 곱하고, 마지막에서 세 번째 자리는 자리 숫자에 자릿값인 n<sup>2</sup>를 곱하고, ... 자리 숫자와 자릿값을 더해 10진수를 계산한다. (교재 예제보기)

### (2) 아스키 코드

#### 1️⃣ 아스키 코드(ASCII; American Standard Code for Information Interchange) 개념

- 미국 ANSI에서 표준화한 정보교환용 부호체계이다.
- 영문 키보드로 입력할 수 있는 모든 기호가 할당된 기본적인 부호체계이다.

#### 2️⃣ 주요 아스키 코드

| 10진수 |    부호     | 10진수 | 부호 | 10진수 | 부호 |
| :----: | :---------: | :----: | :--: | :----: | :--: |
|   0    |    NULL     |   65   |  A   |   97   |  a   |
|   32   | ' ' (Space) |   66   |  B   |   98   |  b   |
|   48   |      0      |   67   |  C   |   99   |  c   |
|   49   |      1      |   68   |  D   |  100   |  d   |

```c
#include <stdio.h>
void main(){
    char a;
    a = 'A' + 2;
    // 'A'는 65에 2를 더하면 a라는 변수에 67이 저장됨
    
    printf("%d %c", a, a);
    // %d는 10진수 출력이므로 67이 출력,
    // %c는 코드를 출력하므로 'C'를 출력
}
/* 	출력
	67 c
*/
```

## 2️⃣ 변수 활용

### (2) 기본 저장 공간

#### 1️⃣ 변수

##### ① 일반 변수

㉮ 변수(Variable)의 개념

- 변수는 저장하고자 하는 어떠한 값이 있을 때, 그 값을 주기억장치에 기억하기 위한 공간이다.

##### ② static 변수

- static 변수는 프로그램이 시작될 때 변수를 초기화하고, 프로그램이 종료되기 전까지 메모리가 유지되는 변수이다.
- 변수를 static으로 생성하면 처음에 한 번만 초기화가 되며, 함수에 의해서 변수 선언 부분이 여러 번 호출되더라도 초기화하지 않는다.

###### ㉮ C 언어의 static 변수

- C 언어 static 변수 예제

  ```c
  #include <stdio.h>
  void increase(){
      static int count = 0; // static 정수형 변수 count를 선언과 동시에 0으로 초기화
      
      printf("count=%d\n", count); // count 값을 화면에 출력함
      count++;
  }
  
  void main(){
      increase();
      increase();
  }
  /* 	출력
  	count=0
  	count=1
  */ /*
  - static 변수는 프로그램이 종료하기 전까지 변수가 사라지지 않고 계속 유지된다.
  - increase 함수를 호출할 때 count는 static 변수이므로 처음 한 번만 count 값이 0으로 초기화되고,
    increase 함수를 두 번째 호출할 때 static int count = 0;을 만나더라도 count를 0으로
    초기화하지 않는다.
  */
  ```

#### 2️⃣ 배열

##### ② 1차원 배열 선언

###### ㉮ C 언어의 1차원 배열 선언

|        구분        |                   선언                    |
| :----------------: | :---------------------------------------: |
| 초깃값이 없는 경우 |       타입 배열명[배열\_요소\_개수]       |
| 초깃값이 있는 경우 | 타입 배열명[배열\_요소\_개수] = {초깃값}; |

- 배열 요소 개수에 정의된 숫자만큼 같은 타입의 데이터 공간이 할당된다.
- 초깃값을 선언하지 않을 경우 쓰레깃값이 저장된다.
- 배열 요소 개수보다 적은 개수만큼 초기화할 경우 초깃값이 명시되지 않은 값들은 자동으로 0으로 초기화된다.

```c
int a[5] = {1, 2};
/* 배열 요소 개수는 5개이므로 5개의 공간이 잡히고, 초깃값은 1, 2로
   두 개만 명시되어 있으므로 나머지 3개의 공간은 0으로 초기화
*/
```

- C 언어 배열 선언 및 출력 예제

```c
#include <stdio.h>
void main(){
    int a[4] = {1, 2}; // a 배열의 요소 개수는 4개지만, 초깃값은 1, 2로
                       // 두 개만 명시되어 있으므로 나머지 2개의 공간은 0으로 초기화
    int i;
    
    for(i=0; i<4; i++)
        printf("%d\n", a[i]);
}
/* 	출력
	1
	2
	0
	0
*/
```

##### ③ 2차원 배열 선언

###### ㉮ C 언어의 2차원 배열 선언

|        구분        |                      선언                      |
| :----------------: | :--------------------------------------------: |
| 초깃값이 없는 경우 |      타입 배열명[행의 개수]\[열의 개수];       |
| 초깃값이 있는 경우 | 타입 배열명[행의 개수]\[열의 개수] = {초깃값}; |

- (행의 개수)  x (열의 개수)에 정의된 숫자만큼 같은 타입의 데이터 공간이 할당된다.
- 초깃값을 선언하지 않으면 쓰레깃값이 저장된다.
- (행의 개수) x (열의 개수)보다 적은 개수만큼 초기화할 경우 초깃값이 명시되지 않은 값들은 0으로 초기화된다.

- 2차원 배열의 행과 열
  - 2차원 배열이어도 실제 메모리에는 1차원으로 저장되기 때문에 행과 열은 가상의 개념이다. 그래서 타입 배열명[열의 개수]\[행의 개수];로 표현하기도 한다. (수제비 책에서는 [행]\[열] 개념으로 설명한다.)

#### 3️⃣ 포인터

##### ① 포인터(Pointer) 개념

포인터는 변수의 주솟값을 저장하는 공간이다. (교재 그림 참고)

##### ② 포인터 선언

```
데이터 타입* 포인터_변수명 = &변수명;
```

- 데이터 타입 뒤에 *를 붙이면 주소를 저장하는 포인터 변수라는 의미이고,<br>일반 변수명에 &를 붙이면 해당 변수명의 주솟값이다.

- int형 변수를 가리키는 포인터 변수 선언시 int\*를, char형 변수를 가리키는 포인터 변수 선언 시 char\*를, float형 변수를 가리키는 포인터 변수 선언 시 float\*를 사용해야 한다.

- 주소에 해당하는 값을 가리킬 때에는 \*를 사용한다.

   

  ```c
  // 예)
  int a = 10;
  int* b = &a;
  printf("%d %d", a, *b);
  // b가 가리키는(*) 값은 a이므로 *b와 a는 값이 같음
  ```

#### 4️⃣ 배열과 포인터

##### ① 1차원 배열과 1차원 포인터

- 1차원 배열에서 배열명만 단독으로 사용할 경우 1차원 포인터와 동일하다.
- 1차원 배열일 때 배열명[요소] 형태, \*(배열명+요소), 1차원 포인터일 때 포인터[요소] 형태, \*(포인터+요소)일 경우 값을 가리킨다.
- 데이터\_타입 배열명[요소];일 때 다음 코드는 동일하다

###### 배열의 주소와 0번지 값

|      구분       |          코드          |
| :-------------: | :--------------------: |
|   배열의 주소   | 배열명 == &배열명[0];  |
| 배열의 0번지 값 | 배열명[0] == \*배열명; |

```
int a[4];일 때 a 배열의 주소인 a는 &a[0]와 동일하고, a의 0번지 값인 a[0]은 *a와 동일하다.
```

###### C 언어 1차원 배열과 1차원 포인터

```c
#include <stdio.h>
void main(){
    int a[3] = {1, 2}; /* a 배열의 요소 개수는 3개지만, 초깃값은 1, 2만 명시되어 있으므로
                          나머지 1개의 공간은 0으로 초기화 */
    int *p = a;
    
    printf("%d %d %d\n", a[0], a[1], a[2]); // a 배열의 0번지, 1번지, 2번지 값을 출력
    
    printf("%d %d %d\n", *a, *(a+1), *(a+2));
    /* a만 단독으로 쓰면 포인터이므로 a가 가리키는 값,
       a+1이 가리키는 값, a+2가 가리키는 값 출력
    */
    
    
    printf("%d %d %d\n", *p, *(p+1), *(p+2));
    /* p는 a랑 동일하므로 *p, *(p+1), *(p+2)는 각각
       *a, *(a+1), *(a+2)와 동일하게 출력
    */
    
    printf("%d %d %d\n", p[0], p[1], p[2]);
    /* p는 a랑 동일하므로 p[0], p[1], p[2]는
       a[0], a[1], a[2]와 동일하게 출력
    */
}
/* 	출력
	1 2 0
	1 2 0
	1 2 0
	1 2 0
*/

/*
	(a+1)은 a가 가리키고 있는 값에서 1칸 떨어진 곳의 주소라는 뜻
	*(a+1)은 a가 가리키고 있는 값에서 1칸 떨어진 곳의 주소가 가리키는 값이라는 뜻
*/
```

##### ② 2차원 배열과 1차원 포인터

- 2차원 배열에서 배열명만 단독으로 사용할 경우 2차원 포인터와 동일하다.
- 2차원 배열일 때 배열명[요소] 형태, \*(배열명+요소)는 1차원 포인터와 동일하고, 1차원 포인터에 대해 \*과 [ ]을 이용해야 값을 가리킬 수 있다.

###### C 언어 2차원 배열과 1차원 포인터 예제

```c
#include <stdio.h>
void main(){
    int a[3][2] = {1, 2, 3, 4, 5, 6}; // 2차원 배열 선언
    int *p = a[1]; /* a 배열의 1번지 주소(1차원 포인터)를
    p라는 1차원 포인터 변수에 저장 */
    
    printf("%d %d %d\n", *a[0], *a[1], *a[2]);
    // a[] 형태는 1차원 포인터와 같으므로 *을 붙이면 값을 가리킬 수 있음
    
    printf("%d %d %d\n", **a, **(a+1), **(a+1));
    // a 형태는 2차원 포인터와 같으므로 *을 두 번 붙여야 값을 가리킬 수 있음
    
    printf("%d %d\n", *p, *(p+1)); /* p는 a[1]이라고 초기화를 했으므로
    *p는 각각 a[1]이 가리키는 값인 a[1][0]을 출력하고, *(p+1)는 a[1]이 가리키는
    &a[1][0]에서 한 칸 뒤의 값인 a[1][1]의 값을 출력 */
    
    printf("%d %d\n", p[0], p[1]); /* *p와 p[0]는 동일하고
    *(p+1)은 p[1]과 동일하므로 a[1][0], a[1][1] 값이 출력됨 */
}
/*	출력
	1 3 5
	1 3 5
	3 4
	3 4
*/	
```

##### ③ 2차원 배열과 포인터 배열

###### C 언어 2차원 배열과 포인터 배열

```c
#include <stdio.h>
void main(){
    int a[3][2] = {1, 2, 3, 4, 5, 6};
    int *p[3] = {a[2], a[0], a[1]};
    
    
    printf("%d %d %d\n", a[0][0], a[1][0], a[2][0]);
    
    printf("%d %d %d\n", *a[0], *a[1], *a[2]);
    
    
    printf("%d %d %d\n", p[1][0], p[2][0], p[0][0]);
    /*	p[1]은 a[0]이므로 p[1][0]은 a[0][0]를 출력,
    	p[2]는 a[1]이므로 p[2][0]은 a[1][0]를 출력,
    	p[0]는 a[2]이므로 p[0][0]은 a[2][0]를 출력 */
    
    
    printf("%d %d %d\n", *p[1], *p[2], *p[0]);
    /* 	p[1][0]과 *p[1]과 동일하고,
    	p[2][0]과 *p[2]와 동일하고,
        p[0][0]과 *p[0]이 동일 */
}
/*	출력
	1 3 5
	1 3 5
	1 3 5
	1 3 5
*/	
```

##### ④ 2차원 배열과 2차원 포인터

- 2차원 배열에서 배열명만 단독으로 사용할 경우 2차원 포인터와 동일하다.
- 2차원 배열일 때 배열명\[요소]\[요소], \*배열명[요소], \*\*(배열명+요소)일 경우 값을 가리킨다.

###### C 언어 2차원 배열과 2차원 포인터 예제

```c
#include <stdio.h>
void main(){
    int a[3][2] = {1, 2, 3, 4, 5, 6};
    int (*p)[2] = a;
    		
    int (*q)[2] = a+1;
    /* 	p, q라는 2차원 배열 변수에 a 배열의 0, 1번지 주소를
        2차원 포인터 변수에 저장(a는 2차원 배열로 
        a만 단독으로 사용하면 2차원 포인터이므로
        2차원 포인터 형태로 선언) */
    
    // a를 2차원 배열 형태로 출력
    printf("%d %d %d\n", a[0][0], a[0][1], a[1][0]);
    
    // p는 2차원 포인터로 a랑 같으므로 2차원 배열처럼 사용 가능
    printf("%d %d %d\n", p[0][0], p[0][1], p[1][0]);
    
    // q는 2차원 포인터로 a[1][0] 번째를 시작점으로 2차원 배열과 동일하게 사용 가능
    printf("%d %d %d\n", q[0][0], q[0][1], q[1][0]);
}
/*	출력
	1 2 3
	1 2 3
	3 4 5 
*/
```

##### ⑤ 1차원 배열과 문자열

- 문자열을 초기화할 때 마지막에 NULL 문자가 삽입되므로 초기화하는 글자 수보다 1 이상 큰 값으로 배열을 선언한다.(초기화할 때 배열의 크기를 명시하지 않으면 문자열의 문자 수 +1만큼 자동으로 생성)
- printf 함수에서 %s를 이용하여 문자열을 읽고 출력하는데, printf 파라미터로 문자를 읽기 시작할 시작 주소를 알려주면 시작 주소부터 NULL 직전 값까지 읽어서 출력한다.

###### 1차원 배열과 문자열

```c
#include <stdio.h>
void main(){
    // 1차원 char 배열 선언
    char a[7] = "Hello";
    
    // 시작점 a에 해당하는 값인 a[0]부터 NULL값 전인 a[4]까지 출력
    printf("%s\n", a);
    
    // 시작점 a+1에 해당하는 값인 a[1]부터 NULL값 전인 a[4]까지 출력
    printf("%s\n", a+1);
    
    a[4] = NULL; // a[4]의 값을 NULL로 변경
    printf("%s\n", a+1); /* 시작점 a+1에 해당하는 값인 a[1]부터
    NULL값 전인 a[3]까지 출력(a[4]가 NULL로 바뀌었으므로 a[3]까지 출력)
}
/*	출력
	Hello
	ello
	ell
*/	
```

##### ⑥ 2차원 배열의 문자열

- 문자열을 여러 개 정의할 때 2차원 배열을 사용한다.
- printf 함수에서 %s를 이용하여 문자열을 읽고 출력하는데, printf 파라미터로 문자를 읽기 시작할 시작 주소를 알려주면 시작 주소부터 NULL 직전 값까지 읽어서 출력한다.

###### 2차원 배열과 문자열

```c
#include <stdio.h>
void main(){
    // 2차원 char 배열 선언 a[0]에는 "Hello"가, a[1]에는 "Soojebi"가 저장
    char a[2][8] = {"Hello", "Soojebi"};
    
    // 시작점 a[0]에 해당하는 값인 a[0][0]부터 NULL 값 전인 a[0][4]까지 출력
    printf("%s\n", a[0]);
    
    // 시작점 a+1에 해당하는 값인 a[1][0]부터 NULL 값 전인 a[1][7]까지 출력
    printf("%s\n", a[1]);
    
    a[0][4] = NULL; // a[0][4]의 값을 NULL로 변경
    // 시작점 a[0]+2에 해당하는 값인 a[0][2]부터 NULL 값 전인 a[0][3]까지 출력
    printf("%s\n", a[0]+2);
    
    // 시작점 a[1]+3에 해당하는 값인 a[1][3]부터 NULL 값 전인 a[1][6]까지 출력
    printf("%s\n", a[1]+3);
}
/*	출력
	Hello
	Soojebi
	ll
	jebi
*/	
```

### (4) 식별자

#### ① 식별자(Identifier) 개념

- 식별자는 변수, 상수, 함수 등 서로 구분하기 위해서 사용되는 이름이다.
- 프로그램의 구성요소를 구별하기 위해 사용한다.

#### ② 식별자 명명 규칙

##### 식별자 규칙

|      구분      |                             규칙                             |   사용 가능 예시    |                       사용 불가능 예시                       |
| :------------: | :----------------------------------------------------------: | :-----------------: | :----------------------------------------------------------: |
| 사용 가능 문자 |      영문 대문자/소문자, 숫자, 밑줄('_')의 사용이 가능       | a, A, a1, _, _hello |                            ?a, <a                            |
| 변수 사용 규칙 |              첫 자리에는 숫자를 사용할 수 없음               |    _1, a1, a100     |                        1, 1a,1A, 1234                        |
| 변수 사용 규칙 |          변수 이름의 중간에는 공백을 사용할 수 없음          |     my_student      |                          my student                          |
| 변수 의미 부여 |                데이터값의 의미나 역할을 표현                 |    age, student     |                                                              |
| 변수 의미 부여 | 이미 사용되고 있는 예약어의 경우에는<br>변수로 사용할 수 없음 |   For, If, While    | int, short, long, for,<br>while, do, continue,<br>break, if, else |

#### ③ 식별자 표기법

##### 변수 설정 기법

|               표기법                |                             설명                             |
| :---------------------------------: | :----------------------------------------------------------: |
|     카멜 표기법<br>(Camel Case)     | + 식별자 표기 시에 여러 단어가 이어지면 첫 단어 시작만 소문자로 표시하고,<br>각 단어의 첫 글자는 대문자로 지정하는 표기법<br>`예) inputFunction` |
|   파스칼 표기법<br>(Pascal Case)    | + 식별자 표기 시에 여러 단어가 이어지면 각 단어의 첫 글자는 대문자로<br>지정하는 표기법<br>`예) InputFunction` |
|   스네이크 표기법<br>(Snake Case)   | + 식별자 표기 시에 여러 단어가 이어지면 단어 사이에 언더바를 넣는 표기법<br>`예) input_function` |
| 헝가리안 표기법<br>(Hungarian Case) | + 식별자 표기 시 두어에 자료형을 붙이는 표기법<br>+ 식별자 표기 시에 int형일 경우 n, char형일 경우 c, 문자열일 경우 sz를 붙임<br>`예) nScore → 정수형` |

## 3️⃣ 연산자

### (1) 연산자(Operator) 개념

- 연산자는 프로그램 실행을 위해 연산을 표현하는 기호이다.
- 연산자에는 산술 연산자, 시프트 연산자, 관계 연산자, 논리 연산자 등이 있다.

### (2) 연산자 종류

|    연산자     |        연산자         |
| :-----------: | :-------------------: |
|  증감 연산자  |  ++x, x++, --x, x--   |
|  산술 연산자  |     +, -, *, /, %     |
| 시프트 연산자 |        <<, >>         |
|  관계 연산자  | >, <, >=, <=, ==, !=  |
|  비트 연산자  |      &, \|, ^, ~      |
|  논리 연산자  |     &&, \|\|, !d      |
|  삼항 연산자  |    (조건식)? a : b    |
|  대입 연산자  | =, +=, -=, *=, /=, %= |

> 연산자 우선순위 문제 종종 출제됨!
>
> 일반적으로 "증산시 관비 논삼대" 순서대로 우선순위가 높으나,  논리 연산자 중 단항 연산자인 `!`, 비트 연산자 중 단항 연산자인 `~`가 증감 연산자와 산술 연산자 사이에 우선순위가 위치해 있다.
>
> 항의 개수에 따른 연산자 우선순위는 단항 연산자 → 이항 연산자 → 삼항 연산자 → 대입 연산자 순입니다.
>
> **연산자 우선순위**<br>[증산시 관비 논삼대]<br>증감 연산자 / 산술 연산자 / 시프트 연산자 / 관계 연산자 / 비트 연산자 / 논리 연산자 / 삼항 연산자 / 대입 연산자

  ### (4) 연산자 종류 상세

#### 1️⃣ 증감 연산자(Increment & Decrement Operator)

- 증감 연산자는 피연산자를 1씩 증가 혹은 1씩 감소시킬 때 사용하는 연산자이다.

##### 증감 연산자의 종류

| 연산자 |                          내용                           |
| :----: | :-----------------------------------------------------: |
|  ++x   | 변수의 값을 1 증가시킨 후에 해당 변수를 사용하는 연산자 |
|  x++   |   변수를 사용한 후에 변수의 값을 1 증가시키는 연산자    |
|  --x   | 변수의 값을 1 감소시킨 후에 해당 변수를 사용하는 연산자 |
|  x--   |   변수를 사용한 후에 변수의 값을 1 감소시키는 연산자    |

###### C 언어 switch 문 증감 연산자 예제

```c
#include <stdio.h>
void main(){
    int x=3, y=3;
    switch(x++){
        case 3: printf("A: %d\n", x); break;
        case 4: printf("B: %d\n", x);
    } /* x++일 경우 x의 값인 3에 해당하는 case 3으로 이동한 후에
    	x를 1 증가시키므로 case 3 안에 있는 printf를 출력하고 있는
    	x는 4가 출력
     */
    
    switch(++y){
        case 3: printf("C: %d\n", y); break;
        case 4: printf("D: %d\n", y);   
    } /* ++y일 경우 y를 1 증가시킨 후에 y의 값인 4에 해당하는
    	case 4로 이동한 후에 case 4 안에 있는 printf를 출력하고 있는
    	y는 4가 출력 
     */
}
/* 	출력
	A: 4
	D: 4
*/
```

#### 3️⃣ 시프트 연산자(Shift Operator)

시프트 연산자는 비트를 이동시키는 연산자이다.

| 연산자 |                             내용                             |
| :----: | :----------------------------------------------------------: |
|   <<   |   왼쪽 값을 오른쪽 값만큼 비트를 왼쪽으로 이동하는 연산자    |
|   >>   | 왼쪽 값에 오른쪽 값만큼의 부호 비트를 채우면서 오른쪽으로 이동하는 연산자 |

##### 시프트 연산자 자바 코드 예제

```java
public class soojebi{
    public static void main(String[] args){
        System.out.print(3<<2); // 12를 출력함
        System.out.print(8<<3); // 1을 출력함
    }
}
/* 출력
   121
*/
/* 시프트 연산은 왼쪽 시프트 연산인 경우에는 '변수<<이동할비트수'이고,
   오른쪽 시프트 연산은 '변수>>이동할비트수' 형태로 사용하며, 이동할 비트 수만큼 0을 채운다.
   
   위 예제 코드에서 System.out.print(3<<2);에서 3을 2진수로 변환하면 0011이고,
   왼쪽으로 2만큼 시프트를 하면 아래와 같이 할 수 있다.
   
   0011    (10진수 3을 2진수로 변환)
      << 2 (왼쪽으로 2만큼 시프트)
   --------------------------------
   1100 (2진수 왼쪽 시프트 연산 결과)
   왼쪽 시프트한 결과는 2진수 1100이고 10진수로 변환하면 12가 된다.
   
   마찬가지로 System.out.print(8<<3);에서 8을 2진수로 변환하면 1000이고,
   오른쪽으로 3만큼 시프트 하면 아래와 같이 할 수 있다.
   
   1000    (10진수 8을 2진수로 변환)
      << 3 (오른쪽으로 3만큼 시프트)
   --------------------------------
   0001 (2진수 왼쪽 시프트 연산 결과)
```

#### 4️⃣ 관계 연산자(Relation Operator)

관계 연산자는 두 피연산자 사이의 크기를 비교하는 연산자이다.

##### C 언어 관계 연산자

```c
#include <stdio.h>
void main(){
    // 관계 연산 결과가 참일 때 출력
    printf("%d\n", 3==3);
    // 관계 연산 결과가 거짓일 때 출력
    printf("%d\n", 5==3);
}
/* 	출력
	1
	0
*/	
```

##### 자바 관계 연산자

```java
class Soojebi{
    public static void main (String[] args){
        System.out.print(3==3);
        System.out.print(5==3);
    }
}
/* 	출력
	true
	false
*/	
```

##### 파이썬 관계 연산자

```python
print(3==3)
print(5==3)
#  출력
#  True
#  False
```

> C는 참일 때 1, 거짓일 때 0.<BR>자바와 파이썬은 참/거짓을 출력하는데, 자바는 true/false가 소문자로만 이루어져 있고,<br>파이썬은 True/False에서 앞글자가 대문자라는 것을 꼭 기억해두기!

#### 5️⃣ 비트 연산자(Bit Operator)

비트 연산자는 0과 1의 각 자리에 대한 연산을 수행하는 연산자이다.

| 연산자 |                             내용                             |
| :----: | :----------------------------------------------------------: |
|   &    | 두 값을 비트로 연산하여 같은 비트의 값이 모두 1이면 해당 비트 값이 1이 되고,<br>그렇지 않으면 0이 되는 연산자 (AND 연산자) |
|   \|   | 두 값을 비트로 연산하여 같은 비트의 값이 하나라도 1이면 해당 비트 값이 1이 되고,<BR>그렇지 않으면 0이 되는 연산자 (OR 연산자) |
|   ^    | 두 값을 비트로 연산하여 같은 비트의 값이 서로 다르면 해당 비트 값이 1이 되고,<BR>그렇지 않으면 0이 되는 연산자 (XOR 연산자) |
|   ~    | 모든 비트의 값을 반대로 바꾸는 반전 기능을 하는 연산자 (NOT 연산자) |

```c
#include <stdio.h>
void main(){
    printf("%d\n", 13 & 10);
    
    printf("%d\n", 13 | 10);
    
    printf("%d\n", 13 ^ 10);
    
    printf("%d\n", ~13);
}
/*	출력
	8
	15
	7
	-14
*/
```

> - 13을 2진수로 변환하면 1101, 10을 2진수로 변환하면 1010이다.
>
> |                           AND 연산                           |                           OR 연산                            |                           XOR 연산                           |
> | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> | 1101<BR>&   1010     <BR>-----------<BR>1000<BR>              10진수로 변환하면 8 | 1101<BR>\|   1010     <BR>-----------<BR>1111<BR>              10진수로 변환하면 15 | 1101<BR>&   1010     <BR>-----------<BR>0111<BR>              10진수로 변환하면 7 |
> | 같은 자리의 비트의 값이 둘 다<BR> 1인 것만 1이고, 나머지는 0 | 같은 자리의 비트의 값이 둘 다<BR>0인 것만 0이고, 나머지는 1  |      같은 자리의 비트의 값이<BR>같으면 0이고, 다르면 1       |
>
> - NOT 연산은 부호를 반대로 바꾼 값(-13)에 1을 뺀 값인 -14가 출력된다.
>
> > NOT 연산은 2진수로 변환했을 때 각 자릿수에 대해 0이면 1로, 1이면 0으로 변환시키면 되는데,<BR>컴퓨터 구조에 관한 내용을 알고 있어야 하므로...<BR>그냥 부호를 반대로 바꾼 값에 1을 뺀 값이라고 기억해두는게 좋다.

#### 7️⃣ 삼항 연산자(Logic Operator)

삼항 연산자는 조건이 참일 경우 물음표(?)와 콜론(:) 사이의 값을 반환하고, 조건이 거짓일 경우 콜론(:)과 세미콜론(;) 사이의 값을 반환하는 연산자이다.

```
조건식 ? 참일때 값 : 거짓일때 값;
```

**[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}**