---
title: "[운영체제] 프로세스 동기화"
excerpt: "Process Synchronization (1), (2)"
toc: true
toc_sticky: true
toc_label: "주요 목차"
header:
  teaser: /assets/images/operating-system.png

date: 2021-12-22T13:18:18+09:00

categories:
  - OS

tags:
  - Programming
  - 프로그래밍
  - 컴퓨터
  - Computer
  - Computer science
  - Computer engineering
  - 컴퓨터 공학
  - 컴퓨터 과학
  - Operating System
  - 운영체제
  - Process Synchronization
  - 프로세스 동기화
  - Race Condition
  - 임계영역 문제
  - The Critical-Section Problem
  - 데이터의 접근
  - Semaphores
  - 세마포어
  - Busy wait
  - Block & Wakeup
 
last_modified_at: 2021-12-23T12:29:34+09:00
---

## Process Synchronization (1), (2)

<div class="notice">
    <h4>
        🔊 이화여자대학교 반효경 교수님의 2014년 1학기 운영체제 강의를 들으며 정리한 노트입니다.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;캡쳐한 이미지 중 따로 출처 명시를 하지 않은 이미지 또한 반효경 교수님 강의 자료에 있음을 밝힙니다. 
    </h4>
</div>
### 데이터의 접근

<img src="https://user-images.githubusercontent.com/78403443/147015646-56af7064-0145-4673-98af-5c1e54c8c671.png" alt="image" style="zoom:50%;" />

> 위와 같은 데이터의 접근 방식은 데이터가 저장되어있는 위치에서 읽어와서 연산을 하고, 다시 원래의 위치에 반영을 하기 때문에 누가 먼저 읽어갔느냐에 따라서 결과가 달라질 수 있는 프로세스 동기화 문제가 발생한다.

|                      **Race Condition**                      |
| :----------------------------------------------------------: |
| <img src="https://user-images.githubusercontent.com/78403443/147015961-a11e649f-ba61-496d-a6e6-397a7351d210.png" alt="image" style="zoom:50%;" /> |

> Storage Box를 좌측 Execution Box 혼자 사용한다고 하면 문제될게 없지만,<br>위와 같은 식으로 여러 주체가 하나의 데이터를 동시에 접근하려고 할 때를 Race Condition(경쟁 상태)라고 한다. 이런 경쟁 상태에서 어떤 하나의 주체가 읽어갔고 반환하지 않은 상황인데, 그동안에 또다른 주체가 또 읽어간다면 우리가 원치않는 결과를 얻을 수 있다.

#### OS에서 race condition은 언제 발생하는가?

1. kernel 수행 중 인터럽트 발생 시
2. Process가 System call을 하여 kernel mode로 수행 중인데 context switch가 일어나는 경우
3. Multiprocessor에서 shared memory 내의 kernel data

| **OS에서의 race condition (1/3)**<br>interrupt handler v.s. kernel |
| :----------------------------------------------------------: |
| <img src="https://user-images.githubusercontent.com/78403443/147020457-e7dfc724-f580-45e3-a322-f0a8fe9841fc.png" alt="image" style="zoom:50%;" /> |

- ※ 커널모드 running 중 interrupt가 발생하여 인터럽트 처리루틴이 수행
  - → 양쪽 다 커널 코드이므로 kernel address space 공유

| **OS에서의 race condition (2/3)**<br>Preempt a process running in kernel? |
| :----------------------------------------------------------: |
| <img src="https://user-images.githubusercontent.com/78403443/147020699-041aec05-931b-4b5a-868b-403a758b39f4.png" alt="image" style="zoom:50%;" /> |

- 두 프로세스의 address 간에는 data sharing이 없음
- 그러나 system call을 하는 동안에는 kernel address space의 data를 access하게 됨 (share)
- 이 작업 중간에 CPU를 preempt 해가면 race condition 발생

| **OS에서의 race condition (2/3)**<br>Preempt a process running in kernel? |
| :----------------------------------------------------------: |
|        If you preempt CPU while in kernel mode .....         |
| <img src="https://user-images.githubusercontent.com/78403443/147021114-13f067c3-11b7-4d46-baa2-6bea758be6b4.png" alt="image" style="zoom:50%;" /> |

- 해결책: 커널 모드에서 수행 중일 때는 CPU를 preempt(선점)하지 않음<br>커널모드에서 사용자모드로 돌아갈 때 preempt(선점)

| **OS에서의 race condition (3/3)**<br>multiprocessor<br>(CPU가 여러개 있는 환경) |
| :----------------------------------------------------------: |
| <img src="https://user-images.githubusercontent.com/78403443/147021731-63543907-8f65-4682-85cf-ea760e882a7f.png" alt="image" style="zoom:50%;" /> |

어떤 CPU가 마지막으로 count를 store했는가? → **race condition**<br>multiprocessor의 경우 interrupt enable/disable로 해결되지 않음<br>(인터럽트를 막아서 해결할 수 없다)

(해결방법 1) 한번에 하나의 CPU만이 커널에 들어갈 수 있게 하는 방법

(해결방법 2) 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대한 lock / unlock을 하는 방법

### Process Synchronization(프로세스 동기화) 문제

- 공유 데이터(shared data)의 동시 접근(concurrent access)은 데이터의 불일치 문제(inconsistency)를 발생시킬 수 있다
- 일관성(consistency) 유지를 위해서는 협력 프로세스(cooperating process)
- ***<u>Race condition</u>***
  - 여러 프로세스들이 동시에 공유 데이터를 접근하는 상황
  - 데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라짐
- race condition을 막기 위해서는 concurrent process는 동기화(synchronize)되어야 한다

|               **Example of a Race Condition**                |
| :----------------------------------------------------------: |
| <img src="https://user-images.githubusercontent.com/78403443/147022882-be44219b-0bf7-4cf2-ad27-a22626096a7e.png" alt="image" style="zoom:50%;" /> |

※ 사용자 프로세스 P1 수행중 timer interrupt가 발생해서 context switch가 일어나서 P2가 CPU를 잡으면?<BR>원하는 결과가 나오지 않고, 일관성(consistency)이 깨어진 불일치 문제가 생길 수 있다.<BR>(위에서 얘기했던 얘기랑 같은 얘기)

### The Critical-Section Problem(임계영역 문제)

- n개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우
- 각 프로세스의 code segment에는 <u>공유 데이터를 접근하는 코드</u>인 ***<u>critical section(임계영역)</u>***이 존재
- Problem
  - 하나의 프로세스가 *critical section(임계영역)*에 있을 때 다른 모든 프로세스는 critical section(임계영역)에 들어갈 수 없어야 한다

<img src="https://user-images.githubusercontent.com/78403443/147023648-dc99a9bc-1ddb-4314-9375-20588f758f10.png" alt="image" style="zoom:50%;" />

### Initial Attempts to Solve Problem

- 두 개의 프로세스가 있다고 가정 P<SUB>0</SUB>, P<SUB>1</SUB>
- 프로세스들의 일반적인 구조

<img src="https://user-images.githubusercontent.com/78403443/147024443-6c9f7c37-81b4-4628-8385-febc634a6fa2.png" alt="image" style="zoom:50%;" />

> 우리가 공유데이터를 접근하는 코드를 critical section이라고 했다.<br>공유데이터를 그냥 접근하게 하면 동시접근을 통해서 문제가 발생할 수 있기 때문에, 공유데이터를 접근하는 코드 이전에 entry section을 넣어서 lock을 걸게함으로써 여러 프로세스가 동시에 critical section에 들어가는 것을 막고,<br>그 다음에 critical section이 끝났으면 lock을 풀어서(exit section) 다른 프로세스가 critical section에 들어갈 수 있게 해준다.

- 프로세스들은 수행의 동기화(synchronize)를 위해 몇몇 변수를 공유할 수 있다 → synchronization variable

### 프로그램적 해결법의 충족 조건

> critical section문제를 풀기 위해서 만족해야될 조건이 무엇인가?<br>그 조건 3가지...

- ***<u>Mutual Exclusion (상호 배제)</u>***
  - 프로세스 *Pi*가 critical section 부분을 수행 중이면 다른 모든 프로세스들은 그들의 critical section에 들어가면 안된다
- ***<u>Progress (진행)</u>***
  - 아무도 critical section에 있지 않은 상태에서 critical section에 들어가고자 하는 프로세스가 있으면 critical section에 들어가게 해주어야 한다
- ***<u>Bounded Waiting (유한 대기)</u>***
  - 프로세스가 critical section에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 critical section에 들어가는 횟수에 한계가 있어야 한다<br>(특정 프로세스 입장에서 critical section을 못들어가고 지나치게 오래 기다리는 starvation이 생기지 않아야겠다는 얘기)
- ※ 가정
  - 모든 프로세스의 수행 속도는 0보다 크다
  - 프로세스들 간의 상대적인 수행 속도는 가정하지 않는다

> 이러한 조건을 만족하면서 (윗 부분과 같이 소프트웨어적으로) critical section의 문제를 푸는(lock을 잘 걸었다가 푸는) 알고리즘들을 소개한다.

### Algorithm 1

- Synchronization variable

  `int turn;`<br>initially `turn = 0;` → *P<sub>i</sub>* can enter its critical section `if (turn == i)`

  > turn이 0이면 0번 프로세스 차례라는 얘기, turn이 1이면 1번 프로세스

- Process *P<sub><u>0</u></sub>*<br><img src="https://user-images.githubusercontent.com/78403443/147026964-ea6cb427-6bb3-46df-905f-6dfcb4946c3b.png" alt="image" style="zoom:50%;"/>

- Process P<sub><u>1</u></sub><br>

  ```c
  do {
      while (turn != 1);       /* My turn? */
      // critical section
      turn = 0;                /* Now it's your turn */
      // remainder section
  } while (1);
  ```

> 즉, turn은 누구 차례인지 판별하는 변수

> 그러나, 이 방식의 가장 중요한 문제점이 아무도 critical section에 없는데도 불구하고 critical section에 들어가지 못하는 문제가 발생... 즉, progress 조건을 만족하지 못함

Satisfies mutual exclusion, but *not progress*<br>즉, 과잉양보:<br>반드시 한번씩 교대로 들어가야만 함 (swap-turn)<br>그가 turn을 내 값으로 바꿔줘야만 내가 들어갈 수 있음<br>특정 프로세스가 더 빈번히 critical section을 들어가야 한다면?

> 이런 문제 때문에 turn을 교대로만 해줘서는 안되겠다. 해서 다른 방법을 생각해본게 아래...

### Algorithm 2

- Synchronization variables

  - **`boolean flag[2];`**<br>initially **`flag[모두] = false;   /* no one is in CS */`**

  - "*P<SUB>i</SUB>* ready to enter its critical section" **`if (flag[i] == true)`**

    > 여기서는 flag라는 변수를 사용하고 있음.<br>프로세스 2개가 각각 자신의 flag를 가지고 있으며, flag는 본인이 critical section에 들어가고자 한다는 의중을 표시함

- Process *P<SUB>i</SUB>*<br><img src="https://user-images.githubusercontent.com/78403443/147028939-17509a8a-d704-4c05-933d-4272d072aa5d.png" alt="image" style="zoom:50%;" />

  > critical section에 들어갈 때 어떻게 하느냐? (P<sub>i</sub> 입장에서)<br>본인의 flag를 true로 만든다. (내가 지금 critical section에 들어가고자 한다는 의사표시를 하는 것)<br>그 다음 while문으로 상대방 flag를 체크,(상대방도 flag를 셋팅해놨는가? 상대방이 flag를 셋팅해놨으면 기다림)<br>만약 상대방이 flag를 셋팅하지 않았다면 critical section에 들어감.<br>들어갔다가 나올 때 본인의 flag를 false로 만들어준다. (혹시 상대방이 기다리고 있으면 들어갈 수 있게...)

> 그러나 이 알고리즘도 문제가 있다... ㅠ

- Satisfies mutual exclusion, but *not progress requirement*.
- 둘 다 2행까지 수행 후 끊임없이 양보하는 상황 발생 가능

> 이 알고리즘도 마찬가지로 둘이 동시에 들어가는 문제가 발생하지는 않는다.<br>다만, 둘 다 들어가기도 전에 깃발만 들었지 실제로는 아무도 들어가있지 않은 상황인데도 눈치만 살피다가 아무도 들어가지 못하는 상황이 생긴다.
>
> 그래서 생각해본 다음 방법이 3번째 알고리즘...

### Algorithm 3 (Peterson's Algorithm)

- Combined synchronization variables of algorithms 1 and 2.

- Process P<sub>i</sub><br><img src="https://user-images.githubusercontent.com/78403443/147030606-e1c46a45-0a64-4115-a4dd-f6d6f1da3b9a.png" alt="image" style="zoom:50%;" />

  > 이 방법은 위에서 설명한 turn과 flag 두 변수를 모두 사용하고 있다.
  >
  > 프로세스 i가 critical section에 들어가고자 할 때, 제일 먼저 자신의 깃발을 들어서 critical section에 들어가겠다는 의사표현을 하고(`flag[i] = true;`)<br>그리고, turn을 상대방 turn으로 바꿔놓는다.(`turn = j;`)<br>그 다음 들어가기 전에 상대방 flag와 turn을 체크... 상대방이 깃발을 들고 있고, 이번이 상대방 차례(turn)인 두 가지를 모두 만족하는 동안에는 while문을 통해 기다리도록 한다. (`while (flag[j] && turn == j);`)

- *Meets all three requirements*; solves the critical section problem for two processes
- *Busy Waiting(=spin lock)! (계속 CPU와 memory를 쓰면서 wait)*

> 이 방법은 모든 경우의 수를 다 따져서 중간 어딘가에서 CPU를 빼앗긴다 하더라도 위에서 소개했던 [충족조건](https://iceman-brandon.github.io/os/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94/#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%A0%81-%ED%95%B4%EA%B2%B0%EB%B2%95%EC%9D%98-%EC%B6%A9%EC%A1%B1-%EC%A1%B0%EA%B1%B4)을 모두 만족한다.
>
> 하지만, 이 코드도 사실 문제점이 있다... Busy Waiting문제<br>쓸데없이 자원을 낭비하면서 체크... 비효율적

### Synchronization Hardware

- 하드웨어적으로 *Test & Modify*를 *<u>atomic</u>*하게 수행할 수 있도록 지원하는 경우 앞의 문제는 간단히 해결

  <img src="https://user-images.githubusercontent.com/78403443/147032106-c06d2d4e-cf6d-4678-9285-b8a1f5cfed4c.png" alt="image" style="zoom: 60%;" />

  > 사실, 이런 문제가 생겼던 이유는 우리가 어떤 데이터를 읽는거하고, 데이터를 쓰는 것을 하나의 instruction으로 처리할 수 없기 때문에 문제가 생겼던 것이다.
  >
  > 그래서, instruction 하나를 가지고 어떤 데이터를 읽는 작업하고, 데이터를 쓰는 작업을 동시에 실행할 수 있다면(하드웨어적인 instruction이 지원된다면) 대단히 간단하게 lock을 걸고 푸는 문제를 해결할 수가 있다.
  >
  > 즉, 하드웨어적으로 하나의 instruction만 주어지면 이러한 critical section 문제는 아주 쉽게 해결이 된다.<br>하드웨어적으로 이러한 고유의 instruction이 지원이 되는 경우가 많은데 그것이 Test_and_set이라는 instruction이다.
  >
  > 이 Test_and_set instruction은 a라는 데이터의 현재값을 읽어내고, 그 다음에 a라는 데이터의 값을 1로 바꿔주는 이 두 가지의 작업을 atomic하게 하나의 instruction으로 처리하는 것이다.<br>(만약에 a라는 데이터가 원래 0이었다고하면, 0이 읽히고, 그리고 나서 a의 값은 1로 바뀌게 되는 것)<br>(반대로 Test_and_set인데 a의 값이 1이었다면 읽었을 때 1이 읽힐 것이고, 그 값은 다시 1로 셋팅하는 것)

- Mutual Exclusion with Test & Set<br><img src="https://user-images.githubusercontent.com/78403443/147032240-f1e8a714-ce77-4835-b294-687b6a273ca4.png" alt="image" style="zoom:50%;" />

> 여기서 lock이라는 변수를 하나 두고... 처음에는 `lock = false; // 0`<br>critical section에 들어가기 전에 `lock = true; // 1`로 해서 lock을 걸고 들어감<br>이미 lock이 걸려있는지 체크하고(`while (Test_and_Set(lock))`)<br>안걸려있다고 하면 내가 lock을 걸고 critical section에 들어가는 이 두개의 작업을 Test_and_Set이라는 instruction을 이용해서 동시에 실행을 함
>
> 누군가가 이미 lock을 걸어놔서 lock이 1(true)이면 Test_and_Set을 해서 읽어보면 1이 읽힐 것이다. 1이 읽히니까 while문을 계속 돌면서 기다리고 있는다. 그리고 lock의 값은 1로 다시 셋팅

### Semaphores

- 앞의 방식들을 추상화시킴

  > (추상 자료형)
  >
  > 먼저 위에서 나왔던 방식들처럼 프로그래머(사용자)가 이런 작업을 일일히 코딩하는게 아니라 추상 자료형 형태로 제공을 해주고, 프로그래머는 Semaphore를 통해서 프로그래밍을 하면 훨씬 간단한 프로그램을 작성할 수 있다.

- **Semaphore *S***

  - integer variable

    > 정수 값을 가질 수 있다. (정수 값 == 자원의 개수)

  - 아래의 두 가지 atomic 연산에 의해서만 접근 가능<br><img src="https://user-images.githubusercontent.com/78403443/147172174-19d3eddc-d1be-42af-b6a5-0119f6659cde.png" alt="image" style="zoom:50%;" />

> 세마포어 자료형은 P 연산, V 연산 두 가지가 정의된다.
>
> P 연산은 Semaphore 변수 값을(공유 데이터를) 획득하는 과정<br>V 연산은 다 사용하고나서 반납하는 과정
>
> 예를 들어, 변수 값이 5면 P 연산을 5번해서 다섯이서 동시에 가져갈 수가 있음<BR>자원의 개수가 4개인 상태에서 V 연산을 하고나면 원래 상태인 5개로 되돌아온다.
>
> lock을 걸고 푸는 과정은 여기서 Semaphore 변수가 1인 경우를 생각하면 된다.<br>(변수)자원의 개수가 한개니까 P 연산을 하면 lock을 거는 과정이고, V 연산을 하면 lock을 푸는 과정이다.
>
> 구체적으로 P 연산과 V 연산이 어떻게 정의되는지 위 이미지를 통해 보자...
>
> 변수 S에 대해서 P 연산을 하게 되면 그 S 값이 0 이하인 동안에 while문을 돌면서 아무 일도 안하고 기다리게 된다. (자원을 다 가져가고 없는 상태이기 때문) 기다리다가 S 값이 양수가 되면(누군가가 자원을 내어놓으면) 그때 S값을 1 빼고 자원을 획득, 사용
>
> 사용이 다 끝나고 나면 V 연산을 해서 S 값을 1 증가시켜서 반납함
>
> 여기서도 busy waiting 문제는 생김.. 자원이 없는 상태에서도 계속 기다리면서 본인의 CPU 시간을 다 쓰고 반납

#### Critical Section of *n* Processes

<img src="https://user-images.githubusercontent.com/78403443/147174321-c8646414-73c3-4a6c-aaa5-28795217204c.png" alt="image" style="zoom:50%;" />

busy-wait는 효율적이지 못함 (=spin lock)<br>Block & Wakeup 방식의 구현 (=sleep lock)

#### Block & Wakeup Implementation

- Semaphore를 다음과 같이 정의<br><img src="https://user-images.githubusercontent.com/78403443/147175165-b3d6b283-7e6f-4b52-9e6d-84514dfa735d.png" alt="image" style="zoom:50%;" />

  > 여기서는 Semaphore를 위해서 Semaphore 변수 안에는 실제 Semaphore변수 값하고(`int value;`), Semaphore 때문에 잠들어있는 프로세스들을 연결하기 위한 queue가 하나 만들어지게 됨(`struct process *L;`)

- block과 wakeup을 다음과 같이 가정

  - **block**<br>커널은 block을 호출한 프로세스를 suspend시킴<br>이 프로세스의 PCB를 semaphore에 대한 wait queue에 넣음

  - **wakeup(P)**<br>block된 프로세스 *P*를 wakeup시킴<br>이 프로세스의 PCB를 ready queue로 옮김

    <img src="https://user-images.githubusercontent.com/78403443/147175352-6759f507-a9c6-4377-acb4-5fac40b6ff76.png" alt="image" style="zoom:50%;" />

> 그래서 만약에 지금 semaphore를 획득할 수 없으면 그 프로세스를 block시키게 되고, 누군가가 semaphore를 쓰고나서 반납을 하게되면 block된 프로세스 중에 하나를 깨워서 wakeup을 시키게 된다.
>
> 예를 들어 semaphore 변수가 하나 있다고 하면, 그 친구를 누군가는 획득을 했을 것이고, 획득을 못한 친구들은 바로 위 이미지와 같이 PCB를 Semaphore변수 queue에다가 매달아 두는 것이다.<br>(여기서는 semaphore를 기다리면서 잠들어있는 프로세스들을 연결을 해놓는 것)

구체적으로 어떻게 구현이 되는지 살펴보자.

##### Implementation<br>block & wakeup version of P() & V()

- Semaphore 연산이 이제 다음과 같이 정의됨<br><img src="https://user-images.githubusercontent.com/78403443/147177051-10a27c98-420b-4e14-a839-e8264e31d52a.png" alt="image" style="zoom:50%;" />

> P 연산은 자원을 획득하는 과정...<BR>자원에 여분이 있다면 획득을 바로 할 것이고,<BR>자원에 여분이 없다면 잠든다.(block 상태로 들어감)
>
> V 연산은 자원을 다 쓰고나서 반납을 하는 것, 그러나 block & wakeup 방식에서는 반납하고 끝나는게 아니라 혹시 이 자원을 기다리면서 잠들어있는 프로세스가 있다면 그것을 깨워주는 작업이 같이 들어가야한다.
>
> S는 Semaphore 변수...<BR>S 하나에 값이 있을 것이고, 프로세스를 연결하는 List가 있을 것임.<br>먼저 P 연산에서는 그 Semaphore 변수 값을 1 빼준다.(`S.value--;`)<br>그런 다음에 그 값이 만약 음수라고 하면(`S.value < 0`) 이미 누군가가 다 가져가고 자원의 여분이 없다는 얘기이므로 이때는 이 프로세스를 `S.L(리스트)`에다가 연결시킨다음에 `block();`을 시킴<br>그러면 이 친구는 block 상태에 있다가 자원이 생기면 그때 깨어날 수가 있는 것인데...
>
> 자원을 이미 쓰고 있는 프로세스가 다 쓰고나면 그 S의 value를 1 증가 시키고(`S.value++;`), 그런 다음에 만약 S.value가 0 이하라고 하면(`if (S.value <= 0)`)(조심해야하는 부분... S.value가 0 이상일 때 자원의 여분이 있는게 아니고, 여기서(P(S) 첫번째 줄)는 일단 S의 값을 빼고나서 잠들었음.. 그래서 만약 내가 지금 자원을 내놓았는데도 불구하고 그 값이 0 이하라는 것은 이 친구를 기다리면서 누군가가 지금 잠들어있다는 뜻이다) 잠들어있는 프로세스 하나를 그 Semaphore의 List에서(`S.L`) 빼가지고 그 프로세스를 깨워주는 작업을 해야한다는 것
>
> 여기서 S.value는 자원의 개수를 세는 의미하고는 좀 다르다...<br>S값이 음수가 되버리면 누군가가 자원을 기다리고 있다는 의미가 되고, 양수면 자원에 여분이 있기 때문에 기다리지 않고 쓰고 있는 상황이다. 라는 상황을 나타내는 거라서 앞서 나왔던거 하고는 조금 의미가 다르다는 것을 유념해서 봐야한다.<br>즉, 누군가 깨워야 될 것이 있는지 없는지를 확인하기 위해서 value값을 사용하는 개념이라는 것

#### Which is better?

- Busy-wait v.s. Block & Wakeup

  > 지금까지 Semaphore를 구현하는 방식에 있어서 Busy-wait를 쓸 것이냐 Block & Wakeup을 쓸 것이냐 두 가지에 대해서 설명을 했음

- Block & Wakeup overhead v.s. Critical Section 길이

  - Critical section의 길이가 긴 경우 Block & Wakeup이 적당

  - Critical section의 길이가 매우 짧은 경우 Block & Wakeup 오버헤드가 busy-wait 오버헤드보다 더 커질 수 있음

    > Block & Wakeup도 오버헤드가 있다. 어떤 프로세스의 상태를 Ready상태에서 잠드는 상태로 바꿔야되고, 나중에 자원이 반납되면(공유데이터에 여분이 생기면) Block 상태에 있던걸 다시 Ready상태로 바꿔줘야되는 작업이 필요하기 때문에
    >
    > Critical section의 길이가 매우 짧은 경우 busy wait방식을 써도 크게 문제가 없다.

  - 일반적으로는 Block & Wakeup 방식이 더 좋음

    > 당연히 쓸데없이 CPU를 계속 쓰면서 기다릴 필요가 없이 자원을 누군가가 가지고 있다고 하면 그냥 CPU 반납하고 Block 상태로 들어가는게 전체적으로 CPU도 훨씬 더 의미있게 이용하는 비율이 높아질 것임

#### Two Types of Semaphores

> Semaphore도 2가지 종류로 나눠볼 수 있는데...(이미 설명했던 개념)

- ***<u>Counting semaphore</u>***

  > semaphore 변수 값이 5나 10 이렇게 주어질 수 있는 경우<br>(즉, 자원의 개수가 여러개 있어서 여분이 있으면 가져다 쓸 수 있는 경우)

  - 도메인이 0 이상인 임의의 정수값

  - 주로 resource counting에 사용

    > 여분의 자원을 counting 하는 용도로

- ***<u>Binary semaphore</u>*** (=mutex)

  > 자원의 개수가 하나인 경우<br>(보통, 락을 걸 때 자원의 개수를 하나로 셋팅해서 사용... 이와 같은 경우)

  - 0 또는 1 값만 가질 수 있는 semaphore
  - 주로 mutual exclusion (lock/unlock)에 사용

#### Deadlock and Starvation

> Semaphore는 쓸 때 주의할 점이 있다. 원치않는 문제가 생길 수 있는데...

- ***<u>Deadlock</u>***

  - 둘 이상의 프로세스가 서로 상대방에 의해 충족될 수 있는 event를 무한히 기다리는 현상

- S와 Q가 1로 초기화된 semaphore라 하자.<br><img src="https://user-images.githubusercontent.com/78403443/147181264-ade95d2b-8cce-4921-8e2d-3e2f52b7c793.png" alt="image" style="zoom:50%;" />

  > 어떤 일을 하기 위해서 세마포어 S하고 Q를 모두 획득한 다음에 일을 하고, 반환하는 방식을 P<sub>0</sub>, P<sub>1</sub> 둘다 하는데... S와 Q는 배타적으로 프로세스 하나만 동시에 사용할 수 있는 1로 초기화된 세마포어라고 하면...<br>
  >
  > P<sub>0</sub>이 자원 하나(S)를 획득하고, P<sub>1</sub>은 또다른 자원 하나(Q)를 획득한 상태에서 둘이서 하나씩 쥐고 놓지는 않고 상대방이 가진 것을 기다리면서 영원히 조건을 충족하지 못하는 이런 Deadlock 상황의 문제가 발생할 수 있다.
  >
  > 이것은 어떻게 해결해야 하느냐?<BR>자원을 획득하는 순서를 똑같이 맞춰주면 해결 가능<BR><img src="https://user-images.githubusercontent.com/78403443/147183169-5a4b7934-f8d6-4159-8dec-c1ea6e87eecb.png" alt="image" style="zoom:50%;" /><BR>(프로그래머가 유의를 해서 작성해야할 부분)

- ***<u>Starvation</u>***

  - *indefinite blocking*. 프로세스가 suspend된 이유에 해당하는 세마포어 큐에서 빠져나갈 수 없는 현상

    > 원래 Starvation이 특정한 프로세스가 영원히 자원을 얻지 못하고 무한히 기다려야되는 상황을 말하는데, 위에 나와있는 deadlock도 일종의 Starvation이라고 볼 수도 있다.
    >
    > 그러나, 여기서 특별히 이야기하는 Starvation은 특정 프로세스들만 자원을 자기들끼리 공유하면서 다른 프로세스는 영원히 자기 차례가 오지 못하게하는 그런 것을 Starvation이라고 부른 것이다.

**[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}**