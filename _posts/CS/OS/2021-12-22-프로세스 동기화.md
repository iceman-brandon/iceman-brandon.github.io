---
title: "[운영체제] 프로세스 동기화"
excerpt: "Process Synchronization (1)"
toc: true
toc_sticky: true
toc_label: "주요 목차"
header:
  teaser: /assets/images/operating-system.png

date: 2021-12-22T13:18:18+09:00

categories:
  - OS

tags:
  - Programming
  - 프로그래밍
  - 컴퓨터
  - Computer
  - Computer science
  - Computer engineering
  - 컴퓨터 공학
  - 컴퓨터 과학
  - Operating System
  - 운영체제
  - Process Synchronization
  - 프로세스 동기화
  - Race Condition
  - 임계영역 문제
  - The Critical-Section Problem
  - 데이터의 접근
 
last_modified_at: 2021-12-22T13:18:18+09:00
---

## Process Synchronization (1)

<div class="notice">
    <h4>
        🔊 이화여자대학교 반효경 교수님의 2014년 1학기 운영체제 강의를 들으며 정리한 노트입니다.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;캡쳐한 이미지 중 따로 출처 명시를 하지 않은 이미지 또한 반효경 교수님 강의 자료에 있음을 밝힙니다. 
    </h4>
</div>
### 데이터의 접근

![image](https://user-images.githubusercontent.com/78403443/147015646-56af7064-0145-4673-98af-5c1e54c8c671.png)

> 위와 같은 데이터의 접근 방식은 데이터가 저장되어있는 위치에서 읽어와서 연산을 하고, 다시 원래의 위치에 반영을 하기 때문에 누가 먼저 읽어갔느냐에 따라서 결과가 달라질 수 있는 프로세스 동기화 문제가 발생한다.

|                      **Race Condition**                      |
| :----------------------------------------------------------: |
| ![image](https://user-images.githubusercontent.com/78403443/147015961-a11e649f-ba61-496d-a6e6-397a7351d210.png) |

> Storage Box를 좌측 Execution Box 혼자 사용한다고 하면 문제될게 없지만,<br>위와 같은 식으로 여러 주체가 하나의 데이터를 동시에 접근하려고 할 때를 Race Condition(경쟁 상태)라고 한다. 이런 경쟁 상태에서 어떤 하나의 주체가 읽어갔고 반환하지 않은 상황인데, 그동안에 또다른 주체가 또 읽어간다면 우리가 원치않는 결과를 얻을 수 있다.

#### OS에서 race condition은 언제 발생하는가?

1. kernel 수행 중 인터럽트 발생 시
2. Process가 System call을 하여 kernel mode로 수행 중인데 context switch가 일어나는 경우
3. Multiprocessor에서 shared memory 내의 kernel data

| **OS에서의 race condition (1/3)**<br>interrupt handler v.s. kernel |
| :----------------------------------------------------------: |
| ![image](https://user-images.githubusercontent.com/78403443/147020457-e7dfc724-f580-45e3-a322-f0a8fe9841fc.png) |

- ※ 커널모드 running 중 interrupt가 발생하여 인터럽트 처리루틴이 수행
  - → 양쪽 다 커널 코드이므로 kernel address space 공유

| **OS에서의 race condition (2/3)**<br>Preempt a process running in kernel? |
| :----------------------------------------------------------: |
| ![image](https://user-images.githubusercontent.com/78403443/147020699-041aec05-931b-4b5a-868b-403a758b39f4.png) |

- 두 프로세스의 address 간에는 data sharing이 없음
- 그러나 system call을 하는 동안에는 kernel address space의 data를 access하게 됨 (share)
- 이 작업 중간에 CPU를 preempt 해가면 race condition 발생

| **OS에서의 race condition (2/3)**<br>Preempt a process running in kernel? |
| :----------------------------------------------------------: |
|        If you preempt CPU while in kernel mode .....         |
| ![image](https://user-images.githubusercontent.com/78403443/147021114-13f067c3-11b7-4d46-baa2-6bea758be6b4.png) |

- 해결책: 커널 모드에서 수행 중일 때는 CPU를 preempt(선점)하지 않음<br>커널모드에서 사용자모드로 돌아갈 때 preempt(선점)

| **OS에서의 race condition (3/3)**<br>multiprocessor<br>(CPU가 여러개 있는 환경) |
| :----------------------------------------------------------: |
| ![image](https://user-images.githubusercontent.com/78403443/147021731-63543907-8f65-4682-85cf-ea760e882a7f.png) |

어떤 CPU가 마지막으로 count를 store했는가? → **race condition**<br>multiprocessor의 경우 interrupt enable/disable로 해결되지 않음<br>(인터럽트를 막아서 해결할 수 없다)

(해결방법 1) 한번에 하나의 CPU만이 커널에 들어갈 수 있게 하는 방법

(해결방법 2) 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대한 lock / unlock을 하는 방법

### Process Synchronization(프로세스 동기화) 문제

- 공유 데이터(shared data)의 동시 접근(concurrent access)은 데이터의 불일치 문제(inconsistency)를 발생시킬 수 있다
- 일관성(consistency) 유지를 위해서는 협력 프로세스(cooperating process)
- ***<u>Race condition</u>***
  - 여러 프로세스들이 동시에 공유 데이터를 접근하는 상황
  - 데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라짐
- race condition을 막기 위해서는 concurrent process는 동기화(synchronize)되어야 한다

|               **Example of a Race Condition**                |
| :----------------------------------------------------------: |
| ![image](https://user-images.githubusercontent.com/78403443/147022882-be44219b-0bf7-4cf2-ad27-a22626096a7e.png) |

※ 사용자 프로세스 P1 수행중 timer interrupt가 발생해서 context switch가 일어나서 P2가 CPU를 잡으면?<BR>원하는 결과가 나오지 않고, 일관성(consistency)이 깨어진 불일치 문제가 생길 수 있다.<BR>(위에서 얘기했던 얘기랑 같은 얘기)

### The Critical-Section Problem(임계영역 문제)

- n개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우
- 각 프로세스의 code segment에는 <u>공유 데이터를 접근하는 코드</u>인 ***<u>critical section(임계영역)</u>***이 존재
- Problem
  - 하나의 프로세스가 *critical section(임계영역)*에 있을 때 다른 모든 프로세스는 critical section(임계영역)에 들어갈 수 없어야 한다

![image](https://user-images.githubusercontent.com/78403443/147023648-dc99a9bc-1ddb-4314-9375-20588f758f10.png)

### Initial Attempts to Solve Problem

- 두 개의 프로세스가 있다고 가정 P<SUB>0</SUB>, P<SUB>1</SUB>
- 프로세스들의 일반적인 구조

<img src="https://user-images.githubusercontent.com/78403443/147024443-6c9f7c37-81b4-4628-8385-febc634a6fa2.png" alt="image" style="zoom:50%;" />

> 우리가 공유데이터를 접근하는 코드를 critical section이라고 했다.<br>공유데이터를 그냥 접근하게 하면 동시접근을 통해서 문제가 발생할 수 있기 때문에, 공유데이터를 접근하는 코드 이전에 entry section을 넣어서 lock을 걸게함으로써 여러 프로세스가 동시에 critical section에 들어가는 것을 막고,<br>그 다음에 critical section이 끝났으면 lock을 풀어서(exit section) 다른 프로세스가 critical section에 들어갈 수 있게 해준다.

- 프로세스들은 수행의 동기화(synchronize)를 위해 몇몇 변수를 공유할 수 있다 → synchronization variable

#### 프로그램적 해결법의 충족 조건

> critical section문제를 풀기 위해서 만족해야될 조건이 무엇인가?<br>그 조건 3가지...

- ***<u>Mutual Exclusion (상호 배제)</u>***
  - 프로세스 *Pi*가 critical section 부분을 수행 중이면 다른 모든 프로세스들은 그들의 critical section에 들어가면 안된다
- ***<u>Progress (진행)</u>***
  - 아무도 critical section에 있지 않은 상태에서 critical section에 들어가고자 하는 프로세스가 있으면 critical section에 들어가게 해주어야 한다
- ***<u>Bounded Waiting (유한 대기)</u>***
  - 프로세스가 critical section에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 critical section에 들어가는 횟수에 한계가 있어야 한다<br>(특정 프로세스 입장에서 critical section을 못들어가고 지나치게 오래 기다리는 starvation이 생기지 않아야겠다는 얘기)
- ※ 가정
  - 모든 프로세스의 수행 속도는 0보다 크다
  - 프로세스들 간의 상대적인 수행 속도는 가정하지 않는다

> 이러한 조건을 만족하면서 (윗 부분과 같이 소프트웨어적으로) critical section의 문제를 푸는(lock을 잘 걸었다가 푸는) 알고리즘들을 소개한다.

#### Algorithm 1

- Synchronization variable

  `int turn;`<br>initially `turn = 0;` → *P<sub>i</sub>* can enter its critical section `if (turn == i)`

  > turn이 0이면 0번 프로세스 차례라는 얘기, turn이 1이면 1번 프로세스

- Process *P<sub><u>0</u></sub>*<br><img src="https://user-images.githubusercontent.com/78403443/147026964-ea6cb427-6bb3-46df-905f-6dfcb4946c3b.png" alt="image" style="zoom:50%;"/>

- Process P<sub><u>1</u></sub><br>

  ```c
  do {
      while (turn != 1);       /* My turn? */
      // critical section
      turn = 0;                /* Now it's your turn */
      // remainder section
  } while (1);
  ```

> 즉, turn은 누구 차례인지 판별하는 변수

> 그러나, 이 방식의 가장 중요한 문제점이 아무도 critical section에 없는데도 불구하고 critical section에 들어가지 못하는 문제가 발생... 즉, progress 조건을 만족하지 못함

Satisfies mutual exclusion, but *not progress*<br>즉, 과잉양보:<br>반드시 한번씩 교대로 들어가야만 함 (swap-turn)<br>그가 turn을 내 값으로 바꿔줘야만 내가 들어갈 수 있음<br>특정 프로세스가 더 빈번히 critical section을 들어가야 한다면?

> 이런 문제 때문에 turn을 교대로만 해줘서는 안되겠다. 해서 다른 방법을 생각해본게 아래...

#### Algorithm 2

- Synchronization variables

  - **`boolean flag[2];`**<br>initially **`flag[모두] = false;   /* no one is in CS */`**

  - "*P<SUB>i</SUB>* ready to enter its critical section" **`if (flag[i] == true)`**

    > 여기서는 flag라는 변수를 사용하고 있음.<br>프로세스 2개가 각각 자신의 flag를 가지고 있으며, flag는 본인이 critical section에 들어가고자 한다는 의중을 표시함

- Process *P<SUB>i</SUB>*<br><img src="https://user-images.githubusercontent.com/78403443/147028939-17509a8a-d704-4c05-933d-4272d072aa5d.png" alt="image" style="zoom:50%;" />

  > critical section에 들어갈 때 어떻게 하느냐? (P<sub>i</sub> 입장에서)<br>본인의 flag를 true로 만든다. (내가 지금 critical section에 들어가고자 한다는 의사표시를 하는 것)<br>그 다음 while문으로 상대방 flag를 체크,(상대방도 flag를 셋팅해놨는가? 상대방이 flag를 셋팅해놨으면 기다림)<br>만약 상대방이 flag를 셋팅하지 않았다면 critical section에 들어감.<br>들어갔다가 나올 때 본인의 flag를 false로 만들어준다. (혹시 상대방이 기다리고 있으면 들어갈 수 있게...)

> 그러나 이 알고리즘도 문제가 있다... ㅠ

- Satisfies mutual exclusion, but *not progress requirement*.
- 둘 다 2행까지 수행 후 끊임없이 양보하는 상황 발생 가능

> 이 알고리즘도 마찬가지로 둘이 동시에 들어가는 문제가 발생하지는 않는다.<br>다만, 둘 다 들어가기도 전에 깃발만 들었지 실제로는 아무도 들어가있지 않은 상황인데도 눈치만 살피다가 아무도 들어가지 못하는 상황이 생긴다.
>
> 그래서 생각해본 다음 방법이 3번째 알고리즘...

#### Algorithm 3 (Peterson's Algorithm)

- Combined synchronization variables of algorithms 1 and 2.

- Process P<sub>i</sub><br><img src="https://user-images.githubusercontent.com/78403443/147030606-e1c46a45-0a64-4115-a4dd-f6d6f1da3b9a.png" alt="image" style="zoom:50%;" />

  > 이 방법은 위에서 설명한 turn과 flag 두 변수를 모두 사용하고 있다.
  >
  > 프로세스 i가 critical section에 들어가고자 할 때, 제일 먼저 자신의 깃발을 들어서 critical section에 들어가겠다는 의사표현을 하고(`flag[i] = true;`)<br>그리고, turn을 상대방 turn으로 바꿔놓는다.(`turn = j;`)<br>그 다음 들어가기 전에 상대방 flag와 turn을 체크... 상대방이 깃발을 들고 있고, 이번이 상대방 차례(turn)인 두 가지를 모두 만족하는 동안에는 while문을 통해 기다리도록 한다. (`while (flag[j] && turn == j);`)

- *Meets all three requirements*; solves the critical section problem for two processes
- *Busy Waiting(=spin lock)! (계속 CPU와 memory를 쓰면서 wait)*

> 이 방법은 모든 경우의 수를 다 따져서 중간 어딘가에서 CPU를 빼앗긴다 하더라도 위에서 소개했던 [충족조건]()을 모두 만족한다.
>
> 하지만, 이 코드도 사실 문제점이 있다... Busy Waiting문제<br>쓸데없이 자원을 낭비하면서 체크... 비효율적

#### Synchronization Hardware

- 하드웨어적으로 *Test & Modify*를 *<u>atomic</u>*하게 수행할 수 있도록 지원하는 경우 앞의 문제는 간단히 해결<br><img src="https://user-images.githubusercontent.com/78403443/147032106-c06d2d4e-cf6d-4678-9285-b8a1f5cfed4c.png" alt="image" style="zoom: 60%;" />

  > 사실, 이런 문제가 생겼던 이유는 우리가 어떤 데이터를 읽는거하고, 데이터를 쓰는 것을 하나의 instruction으로 처리할 수 없기 때문에 문제가 생겼던 것이다.
  >
  > 그래서, instruction 하나를 가지고 어떤 데이터를 읽는 작업하고, 데이터를 쓰는 작업을 동시에 실행할 수 있다면(하드웨어적인 instruction이 지원된다면) 대단히 간단하게 lock을 걸고 푸는 문제를 해결할 수가 있다.
  >
  > 즉, 하드웨어적으로 하나의 instruction만 주어지면 이러한 critical section 문제는 아주 쉽게 해결이 된다.<br>하드웨어적으로 이러한 고유의 instruction이 지원이 되는 경우가 많은데 그것이 Test_and_set이라는 instruction이다.
  >
  > 이 Test_and_set instruction은 a라는 데이터의 현재값을 읽어내고, 그 다음에 a라는 데이터의 값을 1로 바꿔주는 이 두 가지의 작업을 atomic하게 하나의 instruction으로 처리하는 것이다.<br>(만약에 a라는 데이터가 원래 0이었다고하면, 0이 읽히고, 그리고 나서 a의 값은 1로 바뀌게 되는 것)<br>(반대로 Test_and_set인데 a의 값이 1이었다면 읽었을 때 1이 읽힐 것이고, 그 값은 다시 1로 셋팅하는 것)

- Mutual Exclusion with Test & Set<br><img src="https://user-images.githubusercontent.com/78403443/147032240-f1e8a714-ce77-4835-b294-687b6a273ca4.png" alt="image" style="zoom:50%;" />

> 여기서 lock이라는 변수를 하나 두고... 처음에는 `lock = false; // 0`<br>critical section에 들어가기 전에 `lock = true; // 1`로 해서 lock을 걸고 들어감<br>이미 lock이 걸려있는지 체크하고(`while (Test_and_Set(lock))`)<br>안걸려있다고 하면 내가 lock을 걸고 critical section에 들어가는 이 두개의 작업을 Test_and_Set이라는 instruction을 이용해서 동시에 실행을 함
>
> 누군가가 이미 lock을 걸어놔서 lock이 1(true)이면 Test_and_Set을 해서 읽어보면 1이 읽힐 것이다. 1이 읽히니까 while문을 계속 돌면서 기다리고 있는다. 그리고 lock의 값은 1로 다시 셋팅

**[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}**