---
title: "[운영체제] CPU 스케줄링 (1)"
excerpt: "CPU Scheduling (1)"
toc: true
toc_sticky: true
toc_label: "주요 목차"
header:
  teaser: /assets/images/operating-system.png

date: 2021-12-15T17:05:53+09:00

categories:
  - OS

tags:
  - Programming
  - 프로그래밍
  - 컴퓨터
  - Computer
  - Computer science
  - Computer engineering
  - 컴퓨터 공학
  - 컴퓨터 과학
  - Operating System
  - 운영체제
  - CPU Scheduling
  - CPU 스케줄링
  - 프로세스의 특성 분류
  - 선점
  - Preemptive
  - 비선점
  - Non-Preemptive
  - CPU burst
  - I/O burst
  - CPU Scheduler
  - CPU 스케줄러
  - Dispatcher
 
last_modified_at: 2021-12-15T17:05:53+09:00
---

## CPU Scheduling (1)

<div class="notice">
    <h4>
        🔊 이화여자대학교 반효경 교수님의 2014년 1학기 운영체제 강의를 들으며 정리한 노트입니다.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;캡쳐한 이미지 중 따로 출처 명시를 하지 않은 이미지 또한 반효경 교수님 강의 자료에 있음을 밝힙니다. 
    </h4>
</div>
### CPU and I/O Bursts in Program Execution

![image](https://user-images.githubusercontent.com/78403443/146135296-ca852983-b334-4865-91ea-5d35460e431c.png)

> 프로그램이 실행이 되면 어떤 프로그램이든 간에 위와 같은 path를 실행하면서 쭉 진행이 된다.
>
> load store, add store 이런 것들이 CPU에서 instruction을 실행하는 기계어들이다.<br>이것을 실행한다는 것은 Running 한다는 것이다.<br>CPU를 잡고 Running을 하다가 또 중간에 파일에서 어떤 내용을 읽어온다거나 하는 오래 걸리는 작업 이런 부분이 보통 프로그램 안에 포함된다. (이미 나왔던 내용)
>
> 어쨋든 프로그램의 path는 CPU만 연속적으로 쓰는 단계와 I/O를 하는 단계가 이렇게 번갈아가면서 실행이 되는 것
>
> 이런식으로 CPU만 연속적으로 쓰면서 instruction을 실행하는 일련의 단계를 CPU burst라고 부르고,<br>I/O를 실행하고 있는 단계를 I/O burst라고 부른다.
>
> 즉, 어떤 프로그램이든 프로그램이 실행된다는 거는 CPU burst와 I/O burst를 반복하며 실행이 된다. 이렇게 말할 수 있다.
>
> 단, 프로그램의 종류에 따라서 CPU burst와 I/O burst가 굉장히 빈번하게 있는 프로그램이 있고, 또 CPU burst만 아주 진득하게 나오다가 I/O burst가 한번 나오고 이런 프로그램도 있을 수가 있다.<br>(주로 사람이 Interaction을 하는 프로그램이 위 이미지 같이 중간중간에 CPU, I/O가 많이 끼어드는 프로그램이다. 왜냐하면, CPU에서 뭔가 작업을 하고 화면에 뭔가를 출력해주고, 그 다음에 사람이 키보드 입력을 하고 그러면 다시 또 CPU가 뭔가를 실행하고, 그다음 Execution이 됐으면 그 결과를 화면에 보여주고, 사람이 반응을 하고... 이런 Interactive한 job들이 이렇게 CPU burst와 I/O burst가 자주 나오게 되므로)
>
> 즉, I/O가 중간에 자주 끼어든다 이렇게 보면 된다.

### CPU-burst Time의 분포

| ![image](https://user-images.githubusercontent.com/78403443/146137244-5ee93de7-f92a-40e0-a1d5-0cf681f4ca4b.png) |
| :----------------------------------------------------------: |
| *컴퓨터 안에서 돌아가는 프로그램들의 CPU burst time을 그래프로 찍어본 것이다.<br>(CPU burst가 아주 짧은 경우부터 CPU burst가 아주 긴 경우까지를 찍어본 것)<br>그 빈도가 어떤지를 봤더니 CPU burst가 아주 짧은(중간에 I/O가 많이 끼어드는 그런) 경우가 굉장히 많았다는 것이고, CPU burst가 아주 긴 I/O작업 없이 CPU만 진득하게 쓰는 경우는 굉장히 빈도가 낮았다는 것이다.<br>이런식으로 CPU를 짧게 쓰고 중간에 I/O가 끼어드는 이런 종류의 작업을 <u>I/O bound job</u>이라고 부르고, CPU만 아주 굉장히 오랫동안 쓰는 작업을 <u>CPU bound job</u>이라고 부른다.* |

※ 여러 종류의 job(=process)이 섞여 있기 때문에 CPU 스케줄링이 필요하다

- Interactive job에게 적절한 response 제공 요망
- CPU와 I/O 장치 등 시스템 자원을 골고루 효율적으로 사용

> 컴퓨터 안에는 똑같은 종류의 프로그램들만 있는게 아니라 CPU bound job도 있고, I/O bound job도 있는 등 이런 것들이 섞여있기 때문에 CPU 스케줄링이라는 것이 필요하다는 얘기.
>
> 위 그래프를 통해서 CPU bound job이 CPU를 많이 쓰고, I/O bound job은 CPU를 많이 쓴다기 보다는 CPU를 짧게 쓰는데 빈도가 잦은 것이라고 해석할 수 있다.
>
> job의 종류에는 이런 것들이 있고, CPU를 공평하게 주는 것도 좋지만 가능하면 사람하고 Interaction을 하는 이러한 I/O bound job한테 CPU를 더 우선적으로 주는게 필요하다는게 CPU 스케줄링의 중요한 역할 중 하나
>
> 즉, 공평한 것보다도 효율성이 중요할 것이고, 또 I/O bound job같은 Interactive한 job이 너무 오래 기다리지 않게 하는 것, 그게 CPU 스케줄링의 중요한 필요성이다.

#### 프로세스의 특성 분류

- 프로세스는 그 특성에 따라 다음 두 가지로 나눔
  - I/O-*bound process*
    - CPU를 잡고 계산하는 시간보다 I/O에 많은 시간이 필요한 job
    - (many short CPU bursts)
  - CPU-*bound process*
    - 계산 위주의 job
    - (few very long CPU bursts)

### CPU Scheduler & Dispatcher

- ***<u>CPU Scheduler</u>***

  > 누구한테 CPU를 줄지 결정하는 친구<br>운영체제 안에서 CPU 스케줄링을 하는 코드 부분을 CPU Scheduler라고 말함.

  - Ready 상태의 프로세스 중에서 이번에 CPU를 줄 프로세스를 고른다

- ***<u>Dispatcher</u>***

  > (CPU를 누구한테 줄지를 결정했으면) 그 친구한테 CPU를 넘겨주는 역할을 하는 운영체제 커널 코드를 Dispatcher라고 말함.

  - CPU의 제어권을 CPU scheduler에 의해 선택된 프로세스에게 넘긴다
  - 이 과정을 context switch(문맥 교환)라고 한다

- CPU 스케줄링이 필요한 경우는 프로세스에게 다음과 같은 상태 변화가 있는 경우이다

  > 이런 경우가 있겠구나 정도로 생각하면 된다

  1. Running → Blocked (예: I/O 요청하는 시스템 콜)

  2. Running → Ready (예: 할당시간만료로 timer interrupt)

  3. Blocked → Ready (예: I/O 완료 후 인터럽트)

  4. Terminate

     > 4번은 프로세스가 종료되서 더이상 할일이 없으니까 새로운 프로세스한테 CPU를 넘겨야 되는 경우

※ 1, 4에서의 스케줄링은 *<u>nonpreemptive(비선점)</u>* (=강제로 빼앗지 않고 자진 반납)

> 1번과 4번은 CPU를 가지고 있어도 더이상 Instruction 실행이 안되서, 자진 반납하는 경우

※ All other scheduling is *<u>preemptive(선점)</u>* (=강제로 빼앗음)<br>(그 외 다른 모든 스케줄링은 선점의 경우)

> 2번, 3번은 나는 CPU를 계속 쓰고 싶은데 번갈아써야되기 때문에 강제로 CPU를 빼앗기는 것이고,<BR>또 I/O 끝난 프로세스한테 CPU를 넘겨주고 싶지 않은데 내가 우선 순위가 떨어져서 이 친구(I/O 끝난 프로세스)한테 강제로 CPU를 넘겨주고...

> 3번에 대해서...
>
> I/O를 요청했던 프로세스(오래걸리는 작업을 요청한 프로세스)의 I/O 작업이 끝난 경우 그 Device Controller가 인터럽트를 걸어서 프로세스의 상태를 Ready로 바꿔줄 것이다.(CPU를 얻을 수 있는 권한을 다시 주는 것, 당장 CPU만 얻으면 그 다음 Instruction을 실행할 수 있는 그런 상황이 되는 것이다.)
>
> 근데, 이 작업에서 I/O가 끝난 친구는 원래 Ready상태로만 보내지 I/O가 끝났다고 해서 그 친구한테 바로 CPU는 주지 않는다고 보통 지금까지 설명했었다.<BR>I/O가 끝난 작업 전에 CPU를 쓰던 다른 프로세스가 있을 것이다. 그 친구는 CPU를 본인의 할당 시간을 가지고 쓰고 있는데, 또 다른 친구의 I/O가 끝나는 바람에 인터럽트가 걸려서 운영체제가 이 친구의 상태를 Ready로 바꿔준거고 그러면, CPU는 다시 방금 전에 인터럽트 당했던 프로세스한테 넘어가는 것이 일반적이다.
>
> 그런데, 이 상황에서 I/O가 끝난 친구한테 곧바로 CPU를 넘겨야될 때도 있다.<BR>그게 어떤 경우냐면, 여러가지 스케줄링 종류 중 우선 순위(Priority)에 기반한 스케줄링...<br>I/O를 하러 갔던 친구가 우선 순위가 제일 높은 프로세스다(시스템 안에서 최고로 중요한 프로세스다) 라고 하면, 앞에 인터럽트 당했던 프로세스의 시간이 남아있다 하더라도 (그건 할당 시간에 기반한 스케줄링이 아니라 절대적으로 우선 순위에 기반한 스케줄링으로써) I/O 끝난 친구한테 바로 CPU를 넘겨줘야되는 그런 스케줄링도 경우에 따라서 있기 때문에...
>
> 이제 3번 예(I/O 완료 후 인터럽트)의 상황을 이때 스케줄링이 필요할 수도 있다 이렇게 설명을 한 것임

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}