---
title: "[운영체제] 파일 시스템 (1)"
excerpt: "File System (1)"
toc: true
toc_sticky: true
toc_label: "주요 목차"
header:
  teaser: /assets/images/operating-system.png

date: 2022-06-14T18:25:23+09:00

categories:
  - OS

tags:
  - Programming
  - 프로그래밍
  - 컴퓨터
  - Computer
  - Computer science
  - Computer engineering
  - 컴퓨터 공학
  - 컴퓨터 과학
  - Operating System
  - 운영체제
  - File System
  - 파일 시스템
  - File
  - 파일
  - Directory
  - 디렉토리
  - Logical Disk
  - 논리적 디스크
  - 물리적 디스크
  - 버퍼 캐싱
  - Buffer Caching
 
last_modified_at: 2022-06-14T18:25:23+09:00
---

## File System (1)

<div class="notice">
    <h4>
        🔊 이화여자대학교 반효경 교수님의 KOCW 2014년 1학기 운영체제 강의를 들으며 정리한 노트입니다.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;캡쳐한 이미지 중 따로 출처 명시를 하지 않은 이미지 또한 반효경 교수님 강의 자료에 있음을 밝힙니다. 
    </h4>
</div>
### File and File System

> '파일'이라고 하면, 흔히 아는 것처럼 하드디스크에다가 저장하는 단위를 말함.
>
> 우리가 전 챕터에서 '메모리 시스템'에 대해서 배웠는데, '메모리'는 주소를 통해서 접근하는 그런 장치였다.

- <span style='color: pink'><u>***File***</u></span>

  > 반면에 디스크에 일반적으로 저장되는 '파일'이라는 것은 

  - "A named collection of related information"

    > 이름을 통해서 접근하는 단위이다.<br>정의를 하자면, "관련 정보를 이름을 가지고 저장하는 것"을 '파일'이라고 한다.

  - 일반적으로 비휘발성의 보조기억장치에 저장

    > ex) 하드디스크 같은 곳에다가 저장

  - 운영체제는 다양한 저장 장치를 file이라는 동일한 논리적 단위로 볼 수 있게 해 줌

    > 우리가 어떤 데이터를 저장하는 목적으로만 파일을 쓰는게 아니라, 운영체제에서는... 특히, 리눅스 같은 시스템에서는 여러가지 장치들도 관리하기 위해서 파일이라는 이름을 사용해서 관리를 한다.
    >
    > 다양한 저장 장치들... 하드디스크 1번, 하드디스크 2번 ... 이런 것들이 있으면 운영체제는 그러한 장치들을 서로 다른 파일로 관리를 하고 있다. 그래서, 이런식의 파일을 'device special file' 이라 부름. (이것은 우리가 일반적으로 접근하려는 일반 파일과는 좀 다르다)

  - Operation

    > 파일에 대해서 정의되는 연산은?

    - create, read, write, reposition (lseek), delete, open, close 등

      > `reposition (lseek)` (리포지셔닝 하는 연산) : 파일은 여러개 바이트로 구성이 됨, 굉장히 크기 때문에 어느 위치를 읽느냐, 쓰느냐를 가리키는 포인터가 있다. 그래서 대개는 파일을 그냥 읽으면, 그 파일의 시작 부분부터 읽게 되는데 이게 한 번 읽고나면 그 파일의 위치를 가리키는 포인터가 그 다음 부분을 가리키게 된다.<br>그러니까, 쭉 읽으면 위치 포인터는 그 다음 위치로 자동 이동을 하고, 계속해서 그 파일을 읽으면 그 위치부터 읽히게 된다는 것이다.<br>그런데, 우리가 필요에 따라서 파일의 시작 부분 또는 현재 위치 포인터 부분이 아니라 다른 부분부터 읽거나 쓰고 싶을 때가 있을 것이다. 그래서, 그런 파일의 위치를... 현재 접근하고 있는 위치를 수정해주는 그런 연산을 말함.
      >
      > `open, close`는 도대체 왜 하는거냐?<br>일단 정의는 그렇게 되어있다. "read나 write를 하려면 먼저 `open`을 하고나서 read나 write를 해야된다." 인터페이스가 그렇게 되있고, 그 다음에 파일에 대해서 읽고 쓰고 하는 일을 다 끝내서 더 이상 할 일이 없으면, 파일을 `close`해라 이런식으로 되어 있다는 것이다.
      >
      > 그러면, `open`하고 `close`가 왜 굳이 따로 정의가 되있느냐?<br>`open`의 역할은 그 파일을 디스크에서 메모리로 내용을 올려놓는게 아니라, 파일의 `metadata`를 메모리로 올려놓는 작업을 파일의 `open`이라고 부른다. (뒤에 다시 설명 예정)

- <span style='color: pink'><u>***File attribute***</u></span> (혹은 파일의 <span style='color: pink'><u>***metadata***</u></span>)

  > 그 다음에 파일에는... 그 파일 자체의 내용말고 그 파일을 관리하기 위한 정보가 있다. 

  - 파일 자체의 내용이 아니라 파일을 관리하기 위한 각종 정보들

    > 에를 들어, 음악 파일이라고 하면 음악은 그 파일 자체의 내용이지만,

    - 파일 이름, 유형, 저장된 위치, 파일 사이즈

      > 그 파일의 이름이라던지, 그 파일의 유형, 디스크 상에 저장된 위치, 파일 사이즈 이런 것들은 그 파일 자체의 내용하곤 상관이 없는 것이다. 이런 것도 같이 관리가 되야지만 우리가 파일을 관리할 수가 있겠다.

    - 접근 권한 (읽기/쓰기/실행), 시간 (생성/변경/사용), 소유자 등

- <span style='color: pink'><u>***File system***</u></span>

  > 파일 시스템이라는 것은 운영체제에서 파일을 관리하는 소프트웨어 부분이다.

  - 운영체제에서 파일을 관리하는 부분

  - 파일 및 파일의 메타데이터, 디렉토리 정보 등을 관리

    > 파일 시스템은 파일 자체의 내용도 관리해야겠지만, 그 파일의 메타데이터도 같이 저장을 하고 있는 것이다.
    >
    > 그리고, 보통은 파일을 파일 시스템에 저장할 때 그냥 1차원적으로 저장하는게 아니라 디렉토리라는 것을 둬서, 루트 디렉토리부터 계층적으로 저장을 한다. 대부분의 파일 시스템이 디렉토리를 제공하고 있다.
    >
    > 좀 더 보기 편하게 관리상 편의성들을 생각해서 디렉토리를 두고 있다.

  - 파일의 저장 방법 결정

  - 파일 보호 등

    > 그래서, 파일 시스템은 파일을 어떻게 저장할 지, 그리고 그 파일을 어떻게 관리할 지... 파일의 보호 등을 담당하고 있다.

### Directory and Logical Disk

<span style='color: pink'><u>***Directory***</u></span>

- 파일의 메타데이터 중 일부를 보관하고 있는 일종의 특별한 파일

  > 디렉토리도 파일인데, 그 파일의 내용이 그 디렉토리 밑에 있는 파일들이 어떤건지에 해당하는 정보를 그 파일의 내용으로 하는 파일이라는 것이다.
  >
  > 일반 파일은 어떤가? 일반 파일은... 음악 파일이라고 하면 음악이 내용이고, 메타데이터는 그 파일의 이름이나 접근 권한 이런 것이다.

- 그 디렉토리에 속한 파일 이름 및 파일 attribute들

  > 디렉토리 파일은... 그 파일의 메타데이터는 역시 디렉토리 파일의 이름과 디렉토리 파일의 접근 권한 이런게 메타데이터로서 존재할텐데... 디렉토리 파일의 내용은 뭐냐?
  >
  > 디렉토리 파일의 내용이라는거는 그 디렉토리 밑에 존재하는 파일들이 어떤건지, 그 디렉토리 밑에 있는 파일의 메타데이터를 내용으로 하는 파일이 '디렉토리' 파일이라는 것이다.
  >
  > 그래서, 메타데이터는 파일의 이름을 포함해서<br><img src="https://user-images.githubusercontent.com/78403443/173500259-c19e9e03-0bd0-4260-91ab-74181c4f2530.png" alt="image" style="zoom:50%;" /><br>이런 것들이 다 메타데이터인데... 디렉토리에다가 이 메타데이터를 몽땅 저장할 수도 있지만, 그 디렉토리 밑에 있는 파일의 일부 메타데이터는 디렉토리에다가 직접 저장하고, 일부 메타데이터는 다른 곳에다 저장을 하기도 한다. (그거에 대해서는 뒤에서 실제 파일시스템의 예를 통해서 설명 예정)

- operation

  > 디렉토리에 대해서 정의되는 연산은 어떤 것들이 있느냐?

  - search for a file, create a file, delete a file

    > 그 디렉토리 밑에 존재하는 파일들이 어떠한건지 파일의 목록을 보는 것, 디렉토리 밑에 있는 파일을 찾는 것, 그리고 디렉토리에다가 파일을 하나 만드는 것, 그리고 그 디렉토리 밑에 있는 파일을 지우는 거
    >
    > 이러한 것들이 디렉토리에 대해서 정의된 연산이라는 것이다.

  - list a directory, rename a file, traverse the file system

    > 파일의 이름을 바꾸는 것도 있을 수가 있고... 그리고, 파일 시스템 전체를 탐색하는 이런 것`traverse the file system`도 디렉토리 파일에 대한 연산으로 정의가 되있다.

> 결국에는 이런 파일 시스템이 하드디스크에 저장이 될텐데, 이 디스크라는게 논리적인 디스크가 있고, 또 물리적인 디스크가 있다.

<span style='color: pink'><u>***Partition***</u></span> (= <span style='color: pink'><u>***Logical Disk***</u></span>)

> (그 두 가지의 차이는 나중에 설명하겠지만) 운영체제가 보는 디스크라는건 '논리적인 디스크'이다. 그리고, 이 논리적인 디스크를 다른 말로 '파티션' 이라고도 부른다. 우리가 하드디스크 하나 사서 C드라이브, D드라이브 이렇게 파티션을 나누면, 그 각각이 논리적인 디스크가 된다는 것이다.

- 하나의 (물리적) 디스크 안에 여러 파티션을 두는게 일반적

  > 그래서, 디스크 하나를 사서 파티션을 나누면 논리적인 디스크 여러개가 만들어지고,

- 여러 개의 물리적인 디스크를 하나의 파티션으로 구성하기도 함

  > 또, 경우에 따라서는 물리적인 디스크 여러개를 합쳐가지고, 논리적인 디스크 하나를 구성할 수도 있다.

- (물리적) 디스크를 파티션으로 구성한 뒤 각각의 파티션에 <u>***file system***</u>을 깔거나 <u>***swapping***</u> 등 다른 용도로 사용할 수 있음

  > 그래서 이러한 파티션에 즉, 논리적인 디스크에다가 우리가 파일 시스템을 설치할 수가 있고 또는, 이 논리적인 디스크를 전 챕터에서 배웠던 Virtual Memory(버츄얼 메모리) swap area(스왑 에어리어) 용도로 사용을 할 수도 있는 것이다.

  > 그래서, 우리가 디스크의 용도를 크게
  >
  > - 파일 시스템 용도
  > - 스왑 에어리어 용도
  >
  > 이렇게 두 가지로 나눠볼 수가 있는 것이다.

### Open()

아까 `open()` 연산에 대해서 설명을 했었는데, 이 `open()` 이라는 것은 파일의 메타데이터를 메모리로 올려놓는 것이다.

|                          **open()**                          |
| :----------------------------------------------------------: |
| <img src="https://user-images.githubusercontent.com/78403443/173504073-9a1d92e8-61e7-4df9-a190-92d724acfa21.png" alt="image" style="zoom:50%;" /> |

> 우리가 이 논리적인 디스크 안에 파일 시스템이 있으면, 그 파일 시스템의 특정 파일에 메타데이터도 저장이 되있고, 그 파일의 내용도 저장이 되있을 것이다. 메타데이터 중에는, 파일의 저장 위치도 있다. 파일의 저장 위치도 하나의 메타데이터이기 때문에, 이 파일의 메타데이터 중에는 "이 파일이 어디에 저장이 되있다." 파일의 내용을 가리키는 포인터도 같이 저장이 되있을 것이다.
>
> 어쨌거나, 이 파일을 `open()`하게 되면 그 파일에 대한 메타데이터가 메모리로 올라오게 되는 것이다.

- open("/a/b/c")

  > 예를 들어서, `/a/b/c`라는 파일을 open하게 되면, 이 `c`라는 파일의 메타데이터가 메모리로 올라올 것이다. 근데, 이런식으로 디렉토리 경로가 계층적으로 구성이 되있을 때 open을 하라고 하면, 이 `c`라는 파일의 메타데이터가 어디 저장 되있는지를 디스크에서 찾아야 한다.
  >
  > 어떻게 찾느냐하면, 보통 root(루트) 디렉토리의 위치는 미리 알려져있기 때문에 루트 디렉토리부터 경로를 따라 내려가면서 이 `c`라는 파일의 위치를 찾게 되는 것이다. (아래 그림을 통해서 살펴보자)

  - 디스크로부터 파일 c의 메타데이터를 메모리로 가지고 옴
  - 이를 위하여 directory path를 search
    - 루트 디렉토리 "/"를 open하고 그 안에서 파일 "a"의 위치 획득
    - 파일 "a"를 open한 후 read하여 그 안에서 파일 "b"의 위치 획득
    - 파일 "b"를 open한 후 read하여 그 안에서 파일 "c"의 위치 획득
    - 파일 "c"를 open한다
  - Directory path의 search에 너무 많은 시간 소요
    - Open을 read / write와 별도로 두는 이유임
    - 한번 open한 파일은 read / write 시 directory search 불필요
  - Open file table
    - 현재 open 된 파일들의 메타데이터 보관소 (in memory)
    - 디스크의 메타데이터보다 몇 가지 정보가 추가
      - Open한 프로세스의 수
      - File offset: 파일 어느 위치 접근 중인지 표시 (별도 테이블 필요)
  - File descriptor (file handle, file control block)
    - Open file table에 대한 위치 정보 (프로세스 별)

---

> <img src="https://user-images.githubusercontent.com/78403443/173508218-a3c1fb91-7b07-4b94-b202-dc500f6c3b3f.png" alt="image" style="zoom:50%;" />
>
> 왼쪽이 물리적인 메모리, 오른쪽이 논리적인 디스크다.
>
> <img src="https://user-images.githubusercontent.com/78403443/173508480-469257a6-8708-46f2-914b-e4da70d85f5e.png" alt="image" style="zoom:50%;" />
>
> 사용자 프로그램이 '시스템 콜'을 할 수가 있다. 나는 /a 밑에 b라는 파일을 open하겠다.`fd = open("/a/b")`(open도 '시스템 콜'이다.. read, write, open 이런 것들이 다 I/O를 하는 '시스템 콜'임)
>
> 이렇게 open을 하게 되면, 어떤 일이 일어나느냐?<BR>먼저 시스템 콜이니까 CPU 제어권이 운영체제로 넘어갈 것이다. 그럼 운영체제 안에는 각 프로세스 별로 관리하기 위한 자료구조(PCB)가 있고, 또 전체 프로그램들이 지금 open하는 파일들이 어떤건지를 관리하는 글로벌한 테이블이 유지가 되고 있다.
>
> <img src="https://user-images.githubusercontent.com/78403443/173509394-eb038f2b-9d19-4ea7-87be-e02a21d2ee9d.png" alt="image" style="zoom:50%;" />
>
> 그래서, 이렇게 open을 해주면 루트 디렉토리의 메타데이터는 미리 알려져있다고 했다. 그래서 운영체제가 루트 디렉토리의 메타데이터가 어디 있는지를 알기 때문에,
>
> <img src="https://user-images.githubusercontent.com/78403443/173510096-cb7f7353-ea41-45fb-9dc3-da4040a79d78.png" alt="image" style="zoom:50%;" />
>
> 그래서, 루트 디렉토리의 메타데이터를 먼저 메모리에 올린다. 즉, 루트를 먼저 open하는 것이다.
>
> 그러면 메타데이터 가운데에는 그 파일의 위치 정보가 있다고 했다. 
>
> <img src="https://user-images.githubusercontent.com/78403443/173510580-75900286-962f-4250-9911-8a06cf02d5ba.png" alt="image" style="zoom:50%;" />
>
> 그래서, 루트의 메타데이터를 열어보면 루트 디렉토리의 실제 내용이 어디 있는지 그 위치를 찾을 수가 있다.<br>그러면, 루트 디렉토리의 실제 컨텐츠가 예를 들어서, 위 그림과 같이 있다고 해보자. 그럼 이 root라는건 디렉토리 파일이기 때문에, 그 내용이 뭐냐하면 그 디렉토리 밑에 있는 파일들의 메타데이터를 가지고 있다.<br>근데, 루트 밑에 (이것도 물론 디렉토리 파일이지만) `a`라는 파일이 지금 있는 것이다. 그래서, 루트 디렉토리의 내용에 가면 그 중에 `a라는 파일의 메타데이터`가 있을 것이다.
>
>  <img src="https://user-images.githubusercontent.com/78403443/173511429-e2e3e36b-fcb7-4ee7-885c-d1bc7ab0dc53.png" alt="image" style="zoom:50%;" />
>
> <img src="https://user-images.githubusercontent.com/78403443/173511738-f9c7ffd2-6597-4440-b0a1-1567089e3a59.png" alt="image" style="zoom:50%;" />
>
> 그래서, 이 안에 `a라는 파일의 메타데이터`가 존재하기 때문에 그것도 메모리에 올려놓는다. (`a`를 open한 것이다)
>
> 그러면, `a`가 이제 메모리에 메타데이터가 올라와있고, `a의 메타데이터` 중에는 `a`의 파일 시스템 상의 위치 정보가 들어 있을 것이다. 그래서 이 안에 살펴보니까...
>
> <img src="https://user-images.githubusercontent.com/78403443/173512296-75374ded-8a87-4de0-a974-2e8065d0e20e.png" alt="image" style="zoom:50%;" />
>
> `a`가 디스크 어디에 그 내용이 있다는 것을 찾을 수가 있고...<br>`a`라는 파일도 보니까 디렉토리 파일이다. 이 디렉토리 파일에는 그 디렉토리 밑에 있는 파일들에 대한 메타데이터가 있다.
>
> 지금 `b`라는 파일이 그 `a`디렉토리 밑에 있는 파일이니까, `a`안에는(`a`의 내용 중에는) `b라는 파일의 메타데이터`가 또 들어있을 것이다.
>
> <img src="https://user-images.githubusercontent.com/78403443/173513015-d4ba8e90-1d38-4329-b573-46507b3e338e.png" alt="image" style="zoom:50%;" />
>
> 그러면, 이걸 찾아서 또, 메모리에 올려놓는다.
>
> <img src="https://user-images.githubusercontent.com/78403443/173513251-2434c0da-5631-47bf-83cf-7b463bee393c.png" alt="image" style="zoom:50%;" />
>
> 아까 open이라는건 그 파일의 메타데이터를 메모리에 올려놓는 작업이라고 했는데, 지금 `b`라는 파일을 open했고, `b라는 파일의 메타데이터`가 드디어 메모리에 올라왔다. 그러면 이제 open이 끝난 것이다.
>
> open이 끝나면 지금 이 친구`Process A`가 '시스템 콜'을 했기 때문에 어떤 결과값을 리턴하게 되는데, 어떤 값을 리턴하느냐?
>
> <img src="https://user-images.githubusercontent.com/78403443/173513743-e29cedf7-3aec-459c-9975-66c8294ba792.png" alt="image" style="zoom:50%;" />
>
> 각 프로세스마다 그 프로세스가 open한 파일들에 대한 메타데이터 포인터를 가지고 있는 일종의 배열같은게 정의가 되있다. 그래서, 만약에 지금 open한 `b라는 파일의 메타데이터` 위치가 여기 (위 그림 PCB안에 노란색으로 색칠되어 있음)
>
> <img src="https://user-images.githubusercontent.com/78403443/173514383-f69ac746-a064-42eb-ad2b-25d58cb054c6.png" alt="image" style="zoom:50%;" />
>
> 그 친구를 가리키는 포인터가 이(PCB 안) 배열 어딘가에 만들어지고, 이 배열에서 "이게 몇번째 인덱스냐?" 그 인덱스가 바로 `b`라는 파일의 파일 디스크립터(`fd`)(`b의 fd`)가 되서, 
>
>  <img src="https://user-images.githubusercontent.com/78403443/173514812-3b2c7180-e580-4977-a074-eb6763724e3b.png" alt="image" style="zoom:50%;" />
>
> 그 값을 사용자 프로세스한테 리턴을 하는 것이다.
>
> 지금부터는 이 친구`Process A`가 open을 했기 때문에, 이 `b`라는 파일에 대해서 read / write를 하면 도대체 이 `b`라는 파일이 디스크 어디에 있는지를 막 다시 한번 루트 디렉토리부터 따라 내려가면서 찾고, 이런걸 할 필요가 없다 이미 open을 해놨기 때문에.<br>`b`라는 파일의 위치는 `b의 메타데이터`를 보면 나와있다. 그리고, `b의 메타데이터`는 이미 메모리에 올라와있고, 그거의 위치를 지금 '파일 디스크립터`fd`' 가 가지고 있기 때문에, 이 사용자 프로세스`Process A`는 이제 그 '파일 디스크립터' 숫자만 가지고, 즉, 배열의 인덱스만 가지고 read / write 요청을 할 수 있는 것이다.
>
> <img src="https://user-images.githubusercontent.com/78403443/173516435-09953635-6b2b-4679-8b6d-a2cbe7282324.png" alt="image" style="zoom:50%;" />
>
> `read(fd...)`<br>예를 들어서, `b`라는 파일에서 뭔가 읽어오고 싶다. 그러면, 프로그래밍을 해보면  파일 이름 read할 때 argument로 적는게 아니라, open한 다음에 그 파일 디스크립터`fd`를 argument로 적어주게 되어 있다. 디스크립터를 적고 얼만큼 읽어오라던지 그런거를 역시 'read 시스템 콜'에 입력으로 넣어주는 것이다.
>
> 그러면 이제 시스템 콜을 한거니까 다시 cpu가 운영체제한테 넘어간다.<br>"`Process A`가 지금 이 디스크립터`fd`를 가지는 파일에서 뭘 읽어오라고 했네?"`read(fd...)` 그러면, `Process A의 PCB`에 가서 해당 디스크립터에 대응하는 r그 파일의 메타데이터 부분을 `Open file table`오픈 파일 테이블에서 따라간 다음에 이 (여기선, `b의 metadata`)  파일에서 뭔가를 읽어오라고 했으니까, 이 파일의 위치정보가
>
> <img src="https://user-images.githubusercontent.com/78403443/173518578-be12b71c-36e4-4e0d-b372-847e0cc134da.png" alt="image" style="zoom:50%;" />
>
> 디스크 어디에 있는지를 메타데이터가 가지고 있다. 그럼 여기서(`b`에서) 그냥 읽어오라고 했으니까 시작 위치부터 읽어 올 것이다. `Process A`가 요청한 용량만큼... 그 내용을 메모리로 읽어서 이 프로그램`Process A`한테 전달해주면 될 것이다. 근데 이 과정에서 그 내용을 읽어서 
>
> <img src="https://user-images.githubusercontent.com/78403443/173519147-55f21a72-af96-4b3b-ade8-a262a8b6f7a4.png" alt="image" style="zoom:50%;" />
>
> 사용자 프로그램한테 직접 주는게 아니라
>
> <img src="https://user-images.githubusercontent.com/78403443/173519266-0fdd0591-673b-48f5-a409-0a290ac2852d.png" alt="image" style="zoom:50%;" />
>
> 운영체제가 자신의 메모리 공간 일부에다가 먼저 읽어 놓는다. 
>
> <img src="https://user-images.githubusercontent.com/78403443/173519518-fef937d2-50aa-4a82-bd2a-7e2cb07380bc.png" alt="image" style="zoom:50%;" />
>
> 그런 다음에, 이 사용자 프로그램한테 그 내용을 복사(copy)해서 전달을 해준다. 그래서 이제 read라는 작업이 끝난 것이다.
>
> 근데, 방금 전에 이 내용을 운영체제가 자신의 일부 메모리 영역에 copy해놓고서 전달한다고 했다. 만약에, 이 프로그램 또는 다른 프로그램이 동일한 파일의 동일한 위치를 요청하면...read 시스템 콜을 하면, 디스크까지 가는게 아니라 이미 운영체제가 한번 읽어놓은게 있기 때문에, 그것을 바로 전달해줄 수가 있을 것이다.
>
> 이게 바로 '버퍼 캐싱(buffer caching)' 이라는 것이다.
>
> 우리가 전 챕터에서는 버츄얼 메모리 시스템에서 페이징 기법에 대해서 배웠고, 페이징 기법에서는 이미 메모리에 올라와있는 페이지에 대해서는 운영체제가 뭔가 중간에 끼어들지 못하고, 그냥 주소 변환을 하드웨어가 해가지고 바로 접근을 했고,  페이지 폴트가 났으면 그제서야 cpu가 운영체제한테 넘어와서 운영체제가 swap 영역에서 그 페이지를 읽어오고 이런 작업을 했었다.
>
> 근데, 이 파일에 대한 read / write를 하는 이런 시스템에서는 역시 '버퍼 캐시(buffer cache)' 라는 걸 운영체제가 가지고 있는데, 이 파일 시스템의 버퍼 캐시는 요청한 내용이 버퍼 캐시 안에 있든 없든 간에 어쨌든 운영체제한테 cpu 제어권이 넘어가게 된다.<br>무슨 얘기냐...<br>지금은, 이 데이터`fd...`를 요청했는데, 메모리에 안 올라와있었기 때문에, 이걸 읽어다가 이 자리`b의 content내 자리`에다가 버퍼 캐시를 읽어놨다.<br>나중에, 이미 메모리에 있는 거에 대해서 어떤 프로그램이 요청을 한다...
>
> <img src="https://user-images.githubusercontent.com/78403443/173522884-e022560b-95a5-4a52-96ad-a340e625c2ef.png" alt="image" style="zoom:50%;" />
>
> read해가지고 `b`라는 파일의 이 부분을 달라... (위 그림 하늘색 v 표시)<br>그러면, 역시 이거는 시스템 콜이기 때문에, cpu 제어권은 무조건 운영체제로 넘어간다.<br>운영체제가 판단하는 것이다. "아 이게.. 내가 가져온게 이미 있네?" 그러면, 이거를 그냥 전달을 해주는거고, 요청한게 없다면 디스크에서 읽어와서 역시 '버퍼 캐시' 에 올려놓고, 그거를 copy해서 사용자 프로그램한테 전달을 해야된다는 것이다.
>
> 그래서, 파일 시스템의 '버퍼 캐시' 라는 환경에서는 이미 버퍼 캐시에 내용이 있든 없든 간에 시스템 콜을 통해서 cpu가 운영체제한테 넘어온다. 그래서, 이 '버퍼 캐싱' 환경에서는 LRU 알고리즘이나 LFU 알고리즘 같은거를 자연스럽게 사용을 할 수가 있는 것이다. 모든 정보를 운영체제가 다 알기 때문에...
>
> 그래서, 전 시간에 페이징 시스템에서 LRU를 못쓰고, 클락 알고리즘을 썼던 것과는 대조가 된다.
>
> <img src="https://user-images.githubusercontent.com/78403443/173524483-dcce7346-d51e-40da-881e-0b6d7e0c2f7a.png" alt="image" style="zoom:50%;" />
>
> 그래서, 이러한 커널이 유지하는 테이블들에 대해서 여러가지 이름들이 주어진다. 
>
> 파일 디스크립터 테이블(`별 한개 표시`)은 프로세스마다 가지고 있다고 해서 `per-process file descriptor table 이다.` 라고 부르고, 
>
> 그 다음에 Open file table은 파일을 open했으면 프로세스마다 가지고 있는게 아니라, open된 파일의 목록들을 system wide하게 한꺼번에 관리를 하고 있으므로 그래서, 이러한 테이블은 `system-wide open file table 시스템 전체에 하나 존재하는 오픈 파일 테이블이다.` 이렇게 부르는 것이다.







---





**[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}**