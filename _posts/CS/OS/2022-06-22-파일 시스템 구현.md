---
title: "[운영체제] 파일 시스템 구현 (1)"
excerpt: "File Systems Implementation (1)"
toc: true
toc_sticky: true
toc_label: "주요 목차"
header:
  teaser: /assets/images/operating-system.png

date: 2022-06-22T17:42:43+09:00

categories:
  - OS

tags:
  - Programming
  - 프로그래밍
  - 컴퓨터
  - Computer
  - Computer science
  - Computer engineering
  - 컴퓨터 공학
  - 컴퓨터 과학
  - Operating System
  - 운영체제
  - File System Implementation
  - 파일 시스템 구현
  - Allocation of File Data in Disk
  - 디스크 내 파일 데이터의 할당
  - Contiguous Allocation
  - 연속 할당
  - Linked Allocation
  - 연결 할당
  - Indexed Allocation
  - 인덱스 할당
  - UNIX
  - 유닉스
  - UNIX 파일 시스템의 구조
  - FAT File System
  - FAT 파일 시스템
  - Free-Space Management
  - 비어있는 블럭 관리
 
last_modified_at: 2022-06-23T15:38:23+09:00
---

## File Systems Implementation (1)

<div class="notice">
    <h4>
        🔊 이화여자대학교 반효경 교수님의 KOCW 2014년 1학기 운영체제 강의를 들으며 정리한 노트입니다.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;캡쳐한 이미지 중 따로 출처 명시를 하지 않은 이미지 또한 반효경 교수님 강의 자료에 있음을 밝힙니다. 
    </h4>
</div>
### Allocation of File Data in Disk

> 디스크에다가 파일의 데이터를 저장하는 방법은 크게 3가지 방법으로 나눠볼 수 있다.

- Contiguous Allocation

  > 연속 할당을 하는 방법

- Linked Allocation

  > 링크를 둔 연결 할당 방법

- Indexed Allocation

  > 인덱스를 두는 할당 방법

> 파일이라는 것은 크기가 균일하지 않고, 각각 여러 다른 크기를 가지고 있다.

<img src="https://user-images.githubusercontent.com/78403443/174924297-4f37b9c8-018f-4a8f-9b75-e19342b56203.png" alt="image" style="zoom:50%;" />

> 디스크에다가 파일을 저장할 때는 보통, 동일한 크기의 섹터 단위로 나누어서 저장을 하고 있다. 
>
> 파일 시스템이라던지, 디스크 외부에서 볼 때는 각각의 동일한 크기의 저장 단위를 '논리적인 블럭' 이라고 부른다. 그리고, 실제로 디스크 내부에서는 각각의 섹터 단위로 데이터를 저장하고 있다.
>
> 즉, 임의의 크기의 파일을 동일 크기의 블럭 단위로 나누어서 저장을 하고 있음. (메모리 관리에서 페이징 기법하고 조금 유사)

#### Contiguous Allocation

> 연속 할당 방법, 하나의 파일이 디스크 상에 연속해서 저장이 되는 방법

<img src="https://user-images.githubusercontent.com/78403443/174924297-4f37b9c8-018f-4a8f-9b75-e19342b56203.png" alt="image" style="zoom:50%;" />

> 예를 들어서, 
>
> - 블럭 2개로 구성되는 파일은 (위 그림 0, 1번과 같이) 1번째 블럭 하고, 2번째 블럭이 인접한 블럭 번호를 가지게 저장이 되고, 
> - 블럭의 크기가 6개라면, 19번부터 들어간다고 가정했을 때 24번 블럭까지 연속해서 들어가도록 하는 것이 '연속 할당' 이다.
>
> 전 챕터에서 디렉토리라는 파일은 그 디렉토리 밑에 있는 파일들의 메타데이터를 내용으로 한다고 말했었다. 
>
> 그래서, 위 그림을 보면 어떤 디렉토리가 있는데, 
>
> - 그 디렉토리에 파일이 5개가 있으며, 
> - 그리고 디렉토리에는 해당 파일의 메타데이터를 담고 있기 때문에, 파일의 이름이라던지 그 파일의 위치 정보`start` 등을 디렉토리가 가지고 있다.
>
> - `count`라는 파일은.. 연속 할당으로 저장을 한다고 가정하면,<br>`start`0번 위치부터 `length`길이가 2 이므로, 0번과 1번 두 개의 블럭에 걸쳐서 저장이 되는 것이다.

- 단점

  - external fragmentation

    > 위 그림을 보면, 각각의 파일들의 길이가 균일하지 않기 때문에, 중간 중간에 내용이 들어있지 않은 free블럭들(색칠 안되어 있는 애들)이 있게 된다. 따라서, 비어 있는 공간임에도 불구하고, 활용될 수 없는 경우가 생긴다. 그러므로, 외부 조각이 생길 수가 있다.

  - File grow가 어려움

    > 파일은 크기가 중간 중간에 바뀔 수가 있다.(수정을 하면)<br>"File grow가 어렵다"는 얘기는 파일의 크기가 커질 수 있는 것에 제약이 있다는 말이다. 연속 할당이라는 규칙 하에 뒤에 빈 블럭의 수가 필요한 것보다 적은 경우가 생길 수 있기 때문.

    - file 생성시 얼마나 큰 hole을 배당할 것인가?

      > 이 단점을 극복하기 위해 예를 들어, 지금은 길이가 3이지만, 길이가 5까지 커질걸 대비해서 2개를 미리 할당해놓는다고 해도, 미리 할당된 크기 만큼만 파일이 더 커질 수 있지 더 이상 커지기는 어려움.

    - grow 가능 vs 낭비 (internal fragmentation)

      > 그리고, 미리 할당을 해놓으면, 당장 사용되지는 않는 공간이지만, 파일이 커질 경우를 대비해서 할당해놓는 공간이기 때문에, '내부 조각(internal fragmentation)' 이 발생하게 된다. (공간이 낭비 되는 것임)
      >
      > - 외부 조각
      >   - 아무도 사용하지 않는 것이기 때문에 누군가에게 할당될 수 있는 공간을 의미
      > - 내부 조각
      >   - 누군가한테 할당이 됐는데, 아직 사용이 되지 않는 공간

- 장점

  - Fast I/O

    > 빠른 I/O가 가능하다.<BR>특히, 하드디스크 같은 매체는 대부분의 접근 시간이 디스크 헤드가 바깥쪽 트랙에서 안쪽 트랙으로 이동하는 시간이다. 디스크인 경우는 실제로 데이터를 읽거나 쓰는 크기는 별로 상관이 없다.

    - 한번의 seek/rotation으로 많은 바이트 transfer

      > 그래서, 이 방법은 어떤 파일을 통째로 읽고 싶다고 하면, 한 번 seek를 해가지고(디스크 헤드가 한 번 이동을 해가지고), 많은 양의 데이터를 한꺼번에 받아올 수가 있다.
      >
      > 즉, 그림과 같이 길이가 6인 파일이 19번부터 있다고 하면, 19번 위치까지만 seek를 하면, 그 다음부터 나머지의 데이터는 더 이상 seek가 필요없이 읽어올 수 있다. (6개의 블럭들이 같은 트랙 상에 존재한다는 가정 하에... 대부분의 경우에 트랙 안에 여러개의 섹터들이 들어갈 수 있기 때문에 대부분의 경우에는 한번 seek해서 많은 데이터를 읽고 쓰는게 가능, 빠른 I/O를 위해서 효과적)

    - Realtime file 용으로, 또는 이미 run 중이던 process의 swapping 용

      > 그래서, 이러한 연속 할당은 파일 시스템 용도말고, 또다른 용도로 디스크를 사용하는 방법인 프로세스의 swap area용도로 씀. swap area는 파일을 저장하는게 아니라 프로세스의 주소 공간 중에 일부를 물리적인 메모리에서 쫓아내고, 나중에 필요할 때 올려놓고... 이런 용도로 사용함.
      >
      > 파일 시스템이라는 것은 영속적인 공간... 전원이 나가더라도 내용이 유지되어야 하는데, swap area는 그런게 아니다.(프로세스가 끝나면 의미가 없는 정보이기 때문에... 말하자면, 임시로 저장해놓고, 프로세스의 주소 공간... 굉장히 많은 대용량의 크기를 빠르게 디스크로 쫓아냈다가 또 필요하면 빨리 메모리로 올려야되는 것)<br>그렇기 때문에, 이러한 swapping 용도는 공간 효율성보다는 속도 효율성이 더 중요한 데이터에 속한다. 디스크를 많이 차지하고 있더라도 어차피 금방 지워질 데이터이기 때문에, 빠른 I/O를 위해서 연속 할당을 해주는 것이 효과적이다.
      >
      > 또, 파일 중에서는 Realtime 용으로 사용하는 파일이 있을 수 있다. Realtime 이라는 것은 데드라인이 있고, 빠른 I/O가 필요

  - Direct access(=random access) 가능

    > 직접 접근이 가능
    >
    > <img src="https://user-images.githubusercontent.com/78403443/174924297-4f37b9c8-018f-4a8f-9b75-e19342b56203.png" alt="image" style="zoom:50%;" />
    >
    > 예를 들면, `mail`이라는 데이터 파일은 길이가 6인데, 이 파일에서 "앞에서부터 5번째 블럭을 보고 싶다" 그러면, 앞에 4개 블럭을 다 접근을 해야지만 5번째 블럭을 볼 수 있는게 아니다.
    >
    > 연속 할당인 경우에는 `mail`이라는 파일이 19번 블럭에서부터 연속적으로 6개가 저장이 되어있는 것이기 때문에,  "앞에서부터 5번째 블럭이 보고 싶다" 그러면, 19번에다가 숫자 4를 더해주면, 중간 위치에 있는 블럭의 위치를 미리 알 수 있으므로, 바로 5번째 위치인 23번 블럭을 접근할 수 있다.

    > Linked Allocation에서는 하드디스크임에도 불구하고, 직접 접근이 불가능하다.

#### Linked Allocation

> Linked Allocation은 파일의 데이터를 디스크에다가 연속적으로 배치하지 않고, 빈 위치면 아무데나 들어갈 수 있게 배치를 하는 것이다.

<img src="https://user-images.githubusercontent.com/78403443/174949000-2ca41616-d35c-4368-84a9-0ba2407b2978.png" alt="image" style="zoom:50%;" />

> 예를 들어, `jeep`이라는 파일이 있다고 가정하면, 
>
> - 이 파일의 첫번째 블럭`start`은 (디스크의 논리적 블럭 중에서) 9번 블럭에 있고, 9번의 끝에 가면 두번째 블럭이 어디에 있다는 것을 적어놓는다. 
> - 그림에 따르면 두번째 블럭은 16번에 있다.
> - 그러면, 16번에 가면 이 파일의 두번째 블럭 내용이 있고, 더 길다면 세번째 블럭이 어디에 있는지를 16번에다가 적어놓는다. 
> - 세번째 블럭은 1번에 있다는 것을 알 수 있다. 
> - 네번째 블럭은 10번, 
> - 다섯번째 블럭은 25번에 있고,
> - 그 다음에 "더이상 이 파일의 내용이 없다"면, 끝났다는 표시`-1`를 해둔다.
>
> 즉, Linked Allocation은 어떤 파일의 시작 위치만 디렉토리가 가지고 있고, 그 다음 위치, 그 다음 위치는 실제로 그 위치에 가보면 (만약 파일의 길이가 더 길다면) 그 다음 위치를 기록해놓는 방법이다.

- 장점

  - External fragmentation 발생 안 함

    > 디스크에서 비어있는 블럭이면 어디든지 아무 내용이나 들어갈 수 있게 때문에, 외부 조각 발생 안 함

- 단점

  - No random access

    > 예를 들어서, 앞에서부터 그림과 같은 "`jeep`파일에서 네번째 블럭을 보겠다"고 하면, 디렉토리에는 첫번째 블럭 위치만 가지고 있기 때문에, 네번째 블럭을 보려면 첫번째 블럭을 먼저 가봐야한다. 가보면, 두번째 위치가 어딘지 알려주고... 이런식으로 순차적으로 세번째 → 네번째...
    >
    > Linked Allocation에서는 중간 위치를 보려면, 앞에 부분을 다 탐색을 해서 내용을 봐야지만 중간 위치를 볼 수가 있다. (건너뛰는게 불가능)
    >
    > 디스크라는 매체는 직접 접근이 가능한 매체이지만, 여기다가 파일을 관리하는 방법을 Linked Allocation을 쓰게 되면 직접 접근이 안되고, 중간 중간에 내용을 다 접근해야지만 원하는 위치를 갈 수가 있기 때문에 "직접 접근 불가능".

  - Reliability 문제 (`릴라이어빌리티`)

    - 한 sector가 고장나 pointer가 유실되면 많은 부분을 잃음

      > 디스크의 섹터들이 간혹 bad sector가 나거나 할 수 있는데, 예를 들어, 여기서 파일을 구성하는 섹터의 개수가 1천개 된다고 가정 했을 때, 중간에 하나가 bad sector가 나면 그 다음 위치는 모조리 다 접근이 불가능한 상태가 된다.
      >
      > 그래서, 하나의 섹터가 bad sector가 나버리면, 포인터가 상당히 많이 유실돼서 그 뒷 부분을 완전히 다 놓치는 Reliability와 관련된 문제가 생길 수 있다.

  - Pointer를 위한 공간이 block의 일부가 되어 공간 효율성을 떨어뜨림

    - 512 bytes/sector, 4 bytes/pointer

      > 보통 디스크에서 하나의 섹터는 512바이트로 구성이 된다. 
      >
      > 그리고, 디스크 바깥쪽 (컴퓨터에서 디스크를 접근할 때) 디스크에 어떤 데이터를 저장하라는 단위가 512바이트의 배수로 구성이 된다.
      >
      > 근데, 512바이트의 배수를 디스크에다가 저장하라고 요청을 하는데,<br>하나의 섹터의 512바이트에서 다음 위치를 가리키는 포인터를 위해서 4바이트가 소요가 된다면, 실제로 데이터를 저장할 수 있는 위치는 512 - 4바이트가 된다.
      >
      > 보통은 512바이트 단위로 저장을 하라고 요청을 하기 때문에, 그러면, 한 섹터에 들어갈 내용이 다음 위치를 가리키는 포인터 저장때문에, 두 섹터에 저장이 되는 상당히 비효율적인 문제가 생길 수 있다는 것이다.

- 변형

  - *<u>File-allocation table (FAT)</u>* 파일 시스템

    > Linked Allocation을 약간 변형해가지고, 굉장히 효율적인 구현을 하고 있다.

    - 포인터를 별도의 위치에 보관하여 reliability와 공간효율성 문제 해결

#### Indexed Allocation

> Indexed Allocation에서는 직접 접근이 가능하게 하기 위해서, 

<img src="https://user-images.githubusercontent.com/78403443/174960383-accc80c7-f1bb-467f-a929-4a7473c6e8e9.png" alt="image" style="zoom:50%;" />

> 디렉토리에 파일의 위치 정보를 바로 저장하는게 아니라, 먼저 인덱스를 갖다가 가리키게 해놓는다. 디렉토리가 가지고 있는 블럭이 인덱스 블럭이기 때문에, 인덱스 블럭이라는 것은 실제 이 파일의 내용을 담고 있는게 아니라, 이 파일이 어디어디에 저장되어있다는 위치정보를 블럭 하나에다가 쭉 열거해놓는 방식.
>
> 그림의 `jeep`이라는 파일은, 
>
> - 총 5개 블럭으로 구성이 되고,
> - 첫번째 블럭, 9번
> - 두번째 블럭, 16번...
> - 다섯번째 블럭, 25
>
> 인덱스 블럭 안에다가 내용으로 적어놓는 것이다.
>
> 만약 "`jeep` 파일에서 앞에서부터 4번째 블럭을 보고싶다" 면, 인덱스 블럭만 살펴보면 앞에서부터 네번째 블럭은 10번이라는 것을 알고, 네번째 블럭으로 바로 접근 할 수 있다.
>
> 즉, 중간 위치를 보기 위해서 앞에서부터 다 따라가야되는게 아니라, 바로 건너뛰어서 직접 접근이 가능하다는게 인덱스 블럭의 장점이면서, 위에 순차 접근에서 생겼던 중간 중간에 홀이 생기는 문제도 해결. 비어있는 위치라면 어디든 활용이 가능.

- 장점

  - External fragmentation이 발생하지 않음
  - Direct access 가능

- 단점

  - Small file의 경우 공간 낭비 (실제로 많은 file들이 small)

    > 아무리 작은 파일이라 하더라도 '인덱스를 위한 블럭' + '실제 데이터를 저장하기 위한 블럭' 총 2개 필요함.
    >
    > 그래서, 파일이 굉장히 작은 경우 공간 낭비가 있다는 것이다.

  - Too Large file의 경우 하나의 block으로 index를 저장하기에 부족

    > 굉장히 큰 파일의 경우에, 하나의 인덱스 블럭으로 그 파일의 블럭 위치들을 다 표현을 못한다. 블럭 하나가 512바이트 - 4바이트 포인터라고 하면 들어갈 수 있는 개수가 한정돼있다.
    >
    > 그래서, 굉장히 큰 파일의 경우에는 인덱스 블럭 하나로 표시를 할 수가 없기 때문에...

    - 해결 방안

      1. linked scheme

         > 링크드 스킴은 인덱스 블럭에 "실제 이 파일의 위치가 어딘지를 쭉 적다가 끝까지 갔는데, 파일의 크기를 다 커버 못하겠다" 그러면, 마지막에다가 실제 이 파일의 위치가 아니라 또 다른 인덱스 블럭을 가리키게 해놓는 것이다. (미리 약속)

      2. multi-level index

         > 멀티 레벨 인덱스는 하나의 인덱스 블럭이 직접 파일의 위치를 가리키는게 아니라, 이게 또다른 인덱스를 가리키게 해서 (2단계 페이지 테이블 쓰듯이) 인덱스가 두 번 거쳐야지만 가리키게 된다거나... 하는 이런 식으로 하면 굉장히 큰 파일을 표현할 수가 있다.
         >
         > (그렇지만, 인덱스를 위한 공간 낭비가 있다는게 이런 방법의 단점이 될 것이다.)

> 여기까지, 파일을 디스크에 저장하는 기본적인 방법 3가지를 설명함.<br>이 방법들은 우리가 이론적으로 이렇게 할당이 가능하다는 것을 설명한 것임

> 다음 내용은 실제 파일 시스템에서 어떤 할당 방법을 어떻게 쓰는가?<br>또 어떻게 변형해서 사용하는가? 그 부분을 설명.

### UNIX 파일 시스템의 구조

> UNIX는 역사가 굉장히 오래됐고, 이 파일 시스템 구조는 가장 기본적인 파일 시스템 구조이다.
>
> UNIX나 리눅스의 파일 시스템이 이런 기본적인 파일 시스템에서 점점 발전해서 Fast File System 이라는게 나오고, 또 ext2, ext3, ext4 등 굉장히 많은 파일 시스템들이 발전을 해왔다. 이와 같은 것들은 이 기본 구조를 좀 더 효율적으로 어떻게 더 잘 저장할 수 있을지 또, 어떻게 더 효율적으로 시간을 줄여서 할지 이런 것들이 발전해왔다.

 <img src="https://user-images.githubusercontent.com/78403443/174966404-0475ee6a-eb85-4bc1-bfac-d04c2ac5f8fd.png" alt="image" style="zoom:50%;" />

> 그림을 보면 하나의 논리적인 디스크(파티션)가 있다.<br>여기다가 우리가 파일 시스템을 설치를 해놓은 것이다.
>
> UNIX의 파일 시스템은 저장되는 구조가 크게 4가지로 구성이 된다.
>
> - 제일 앞 부분, Boot block이 있고,
> - 두번째, Super block이 있고,
> - 세번째, Inode list라는게 있고,
> - 네번째, Data block이라는게 있다.

<img src="https://user-images.githubusercontent.com/78403443/174969292-c1bf42c3-0765-482a-bd4a-2ff4760a9e0f.png" alt="image" style="zoom:50%;" />

- 유닉스 파일 시스템의 중요 개념

  - Boot block

    - 부팅에 필요한 정보 (bootstrap loader)

      > 그 중에서, 첫번째 나와있는 '부트 블럭'은 UNIX 파일 시스템만 제일 앞에 부트 블럭이 나오는 것이 아니라, 어떤 파일 시스템이던 '부트 블럭'이 항상 제일 앞에 나온다. (이것은 약속이다.) 
      >
      > 왜냐하면, 컴퓨터에 어떤 파일 시스템이 설치되어있는지 모르는데, 컴퓨터 전원을 키면 부팅을 해야될 것이다. 그럼 어디에 있는 데이터를 메모리로 올려서 부팅을 할 수 있느냐? 어떤 파일 시스템을 쓰던 간에 항상 '0번 블럭'을 메모리에 올리면, 이게 바로 'Bootstrap loader(부트스트랩 로더)' 라고 해서 부팅을 하기 위해서 필요한 기본 정보가 0번 블럭에 항상 저장이 돼있다.
      >
      > 이것을 올려놓고, 부트 블럭이 시키는대로 하면, 이 파일 시스템에서 운영체제 커널의 위치가 어딘지를 찾아서 그것을 메모리에 올려서 정상적인 부팅이 다 이루어지도록 하는 역할을 하는게 0번인 '부트 블럭' 이다.

  - Super block

    - 파일 시스템에 관한 총체적인 정보를 담고 있다.

      > 구체적으로 말하자면, 어디가 빈 블럭이고, 어디가 실제로 파일이 저장된 사용 중인 블럭인지 이런 것들을 관리 해야될 것이다. 
      >
      > 또, 다음에 나와있는 Inode list와 관련된 것도 어디까지가 Inode list가 있고, 어디부터 실제 Data block이 있고... 이런 것들을 'Super block'이 총체적으로 관리를 해주는 것이다.

  - Inode

    > 지금까지는, 파일의 메타데이터는 그 파일을 가지고 있는 디렉토리에 가면, 그 파일의 메타데이터가 기록돼있다. 이렇게 배웠다. 그런데, 실제 파일 시스템의 구현에서는 디렉토리가 메타데이터를 다 가지고 있지는 않다.
    >
    > 특히, 유닉스의 파일 시스템의 경우에는 디렉토리는 지극히 일부만 가지고 있고, 실제 파일의 메타데이터들은 별도의 위치에다가 빼서 보관을 하고 있는데, 그 위치가 바로 'Inode list' 라는 부분이다.

    - 파일 이름을 제외한 파일의 모든 메타데이터를 저장

      > <img src="https://user-images.githubusercontent.com/78403443/174966404-0475ee6a-eb85-4bc1-bfac-d04c2ac5f8fd.png" alt="image" style="zoom:50%;" />
      >
      > 그림을 보면, 'Inode'라는게 'Index node'인데, Inode라고 하는 것들이 빨간색으로 표시된 것처럼 하나씩 저장될 수 있는 위치가 있고, 이 빨간색으로 표시된 Inode 하나가 파일 하나 당 (Inode가) 하나씩 할당이 되는 것이다.
      >
      > 그리고, 이 Inode는 그 파일의 메타데이터를 가지고 있는 구조이다.<br>(메타데이터는 파일의 소유주라던지, 접근 권한, 최종 수정된 시각, 위치 정보 이런것들을 가지고 있다.)
      >
      > 근데, 이 유닉스 파일 시스템에서 파일의 메타데이터를 전부 Inode가 가지고 있는건 아니고, 딱 한 가지! 파일의 이름은 디렉토리가 가지고 있다.
      >
      > 즉, 디렉토리에 가면 그 디렉토리 밑에 있는 파일의 메타데이터가 저장돼있다고 했는데, 그 메타데이터 중에 파일의 이름은 디렉토리가 직접 가지고 있고, 나머지 메타데이터들은 Inode에 저장이 되있기 때문에, 디렉토리에 가면, 해당 파일에 대한 Inode번호를 가지고 있는 것이다.
      >
      > 그래서, 만약 "Inode 10번이다" 라고 하면, 이 파일의 나머지 메타데이터들은 'Inode list'에서 10번째 가면, 10번 Inode에 그 파일의 메타데이터가 저장이 된다는 것이다.
      >
      > "Inode 라는게 있다." 이게 유닉스 파일 시스템의 가장 핵심적이고, 기본적인 구조이다.
      >
      > 그러면, 그 파일의 위치 정보는 어떻게 저장하고 있느냐?<br>유닉스 파일 시스템은 기본적으로 Indexed Allocation을 변형해서 사용하고 있다.(Indexed Allocation 거의 그대로 쓰긴 함)
      >
      > Inode라는 것은 어차피 크기가 고정돼있다. 각 파일 당 Inode크기가 가변적인게 아니고, 미리 할당된 크기들이 구성이 되있는 것이기 때문에, 여기서 표시될 수 있는 위치 정보를 나타내는 포인터 개수도 유한한 것이다. 그렇지만, 가급적 작은 Inode를 가지고, 굉장히 큰 파일을 표현할 수 있어야 한다.
      >
      > 그래서 UNIX에서는 Indexed Allocation 중에서 `direct index`가 있고, `single indirect`, `double indirect`,  `triple indirect` 이렇게 4가지로 그 파일의 위치 정보를 구성한다.
      >
      > - 파일의 크기가 굉장히 작다면, `direct index`로만 가지고 그 파일의 위치를 표현할 수가 있는 것이다. `direct index`포인터가 유한한 개수가 있는데, 굉장히 작은 파일이면 이 포인터 몇 개만 가지고, 그 파일`data`의 위치를 충분히 가리킬 수가 있다.
      > - 대단히 큰 파일인 경우에는, indirect를 이용해서 `single indirect`라는 것은 한 번 따라가면, 그 파일의 내용이 있는게 아니라 인덱스 블럭이 어딘가에 있고, 그 인덱스 블럭에는 포인터가 또 여러개 들어갈 수가 있음... 거기에 실제 파일의 내용`data`을 가리키는 포인터들이 위치하는 것임.
      > - 더 큰 파일을 표현하겠다면, 그 밑에 있는 포인터 하나인 `double indirect`가 그 용도로 쓰이는 것이다. 한 번 따라가면, 인덱스가 있는게 아니라 거기에서 또 한 번 따라가야지만, 실제 파일의 위치를 가리키는 인덱스들이 있고, 여기서 이제 실제 파일 위치`data`가 저장이 돼있는 것이다.
      > - 이걸로도 부족하다... 파일이 엄청 크다 그러면, `triple indirect`포인터를 쓰는 것이다. 이것은 3단계 인덱스 구조가 있고, 그것을 다 통과해야지만, 실제 파일의 위치 정보가 있다는 것이다.
      >
      > (바로 위 그림 참고하면서 보기)
      >
      > 이게 왜 효율적이냐?<br>대부분의 파일은 크기가 아주 작다. 그리고, 작은 파일들은 한 번의 포인터 접근으로 Inode만 메모리에 올려놓으면 즉, open이 돼있으면 파일의 위치를 바로바로 알 수가 있고...
      >
      > 그 다음에, 가끔 발생하는 일이긴 하지만, 굉장히 큰 파일이다 그러면 indirect 블럭들을 이용해서 인덱스를 디스크에서 추가적으로 접근해서, 그 파일의 위치를 찾는 것이다.
      >
      > 이런식으로 해서, 실제로 계산을 해보면 굉장히 큰 파일을 한정된 크기의 Inode로 지원할 수 있다는 것을 확인할 수 있다.

<img src="https://user-images.githubusercontent.com/78403443/174969292-c1bf42c3-0765-482a-bd4a-2ff4760a9e0f.png" alt="image" style="zoom:50%;" />

> 그래서 요약을 하자면, 유닉스에서는 
>
> - Boot block
> - Super block
> - Inode list
> - Data block
>
> 으로 디스크를 관리하고 있고, 그 중에 파일의 메타데이터는 Inode에다가 별도로 관리를 한다.

### FAT File System

> FAT 파일 시스템은 마이크로소프트 사가 MS-DOS를 만들었을 때, 처음 만든 파일 시스템이다. 최근에도, 윈도우즈 계열과 일부 모바일 환경에서 FAT 파일 시스템을 일부 사용하는 경우가 있다.

<img src="https://user-images.githubusercontent.com/78403443/175198459-c5ec34b2-b7ae-4081-b2d2-b97c22bd6844.png" alt="image" style="zoom:50%;" />

> FAT 파일 시스템은 위 그림과 같이 Boot block, FAT, Root directory, Data block 이런 구조로 되어있다.
>
> - 부트 블럭
>   - 어떤 파일 시스템이든 마찬가지로, 부팅과 관련된 정보를 담고 있음.
> - FAT
>   - FAT 파일 시스템에서는 파일의 메타데이터 중에 일부를 FAT이라는 곳에 보관하고 있다.
>   - 메타데이터 중에서 일부라는 것은 지극히 제한적인 위치 정보만 FAT에다가 따로 빼놓고 있고, 나머지 메타데이터는 디렉토리가 가지고 있다.
>
> 즉, 원래 파일의 메타데이터는 디렉토리가 가지고 있다고 했는데, FAT 파일 시스템의 경우에는 파일의 이름을 비롯한 접근 권한, 소유주, 파일의 사이즈 등 모든 것을 디렉토리가 다 가지고 있고, 심지어 그 파일의 첫번째 위치가 어딘지도 디렉토리가 가지고 있다.
>
> 만약, "첫번째 위치가 217번 블럭이다" 그러면, 217번에 가면 그 파일의 첫번째 내용이 있을 것이다.
>
> 위에 Linked Allocation에서는 첫번째 블럭이 끝날 때, "이 파일의 크기가 크다" 그러면, 두번째 블럭의 위치를 저장하고 있다고 했는데, 그럼으로 인해서 생기는 문제가 몇가지 있었다. 중간에 Bad sector가 나면 뒤에거를 다 찾을 수가 없는 것도 문제였고, 약간의 크기가 줄어듦으로 인해서 512바이트 섹터를 다 활용할 수 없는 것도 문제였다.
>
> FAT 파일 시스템은 그래서 어떤식으로 그 문제들을 해결했냐면, 217번 블럭의 다음 블럭이 뭔지를 FAT이라는 별도의 테이블, 배열에다가 담고 있는 것이다. FAT이라는 테이블의 배열의 크기는, 디스크가 관리하는 데이터 블럭의 개수만큼... N개의 데이터 블럭이 있다면, 배열의 크기가 N개가 되는 것이다. 그 배열에는 숫자를 하나 담을 수 있는데, 그 숫자는 그 블럭의 다음 블럭이 어딘지를 담고 있다.
>
> 즉, 배열에 있는 숫자는 해당 블럭이 어떤 파일에 속한 블럭이라거나 또는, 비어있는 블럭이라거나 이런건 상관없다. 그냥 무슨 의미인지는 모르겠지만, 그 블럭의 다음 블럭을 번호로 저장해놓는 것이다.
>
> 그림의 파일 경우에는 첫번째 블럭이 217번이었다. 
>
> - 217번에 가면, 그 블럭의 내용이 있고, 
> - 두번째 블럭은 FAT에서 217번 엔트리를 가면 618이라고 써져있으니 "이 파일의 두번째 블럭은 618번에 있다" 는 것을 아는 것이다.
> - 세번째 블럭은 어디에 있는지 찾아야 되겠다면, 또 FAT의 618번 엔트리를 가보는 것이다. 그랬더니 339라고 써져있다. 그러면 "이 파일의 세번째 블럭은 339번이다" 는 것을 안다.
> - 네번째 블럭이 있는지 339번 엔트리에 또 가봤더니, 이번에는 "이 파일이 끝났다"는 약속된 번호가 적혀있다. 그러면 이 파일은 339번으로 끝나고, "더 이상의 내용은 없구나" 라는걸 알 수 있다는 것이다.
>
> 이것은 Linked Allocation을 활용한건데, 다음 위치 다음 위치를 찾기 위해서 실제 '데이터 블럭'을 접근해야되는게 아니라, 바로 FAT만 확인해보면 그 파일의 다음 위치가 어디에 있는지를 알 수가 있다는 것이다.
>
> 그래서, 이 FAT 파일 시스템의 또다른 장점은 '직접 접근'이 가능하다는 것이다.<BR>왜 가능하냐?<BR>"이 파일의 네번째 블럭을 보겠다" 그러면, 이 FAT이라는 것은 어차피 작은 테이블이다. 그래서, 이미 메모리에 올라가 있는 상황이고, 그 상황에서 이 파일의 네번째 블럭을 보겠다고 하면,
>
> - 217번 엔트리에 가면 두번째가 618
> - 618에 가면 세번째가 339
> - 339에 가서 만약 네번째가 있다면 숫자 얼마(NNN)
>
> 이렇게 FAT 테이블을 메모리에 올려놓고, 쭉 따라가는 것이기 때문에 이것은 곧바로 그 파일의 네번째 위치가 어딘지를 파악할 수가 있고, 그러면 실제 데이터 블럭...디스크에서 두번째, 세번째 블럭을 봐야지만 네번째 블럭을 알 수 있는게 아니라, 바로 알 수가 있다는 것이다.
>
> 그래서, FAT이라는 파일 시스템은 Linked Allocation의 단점을 모조리 다 극복을 하고 있다.
>
> - 랜덤 엑세스 되고,
> - Reliability 문제 해결하고
>
> 좀 더 구체적으로 어떻게 해결하느냐?<BR>포인터 하나가 유실되더라도(Bad sector가 나더라도) FAT에 내용이 있기 때문에, 데이터 블럭의 내용하고, FAT의 내용하고는 완전 분리가 돼있다. 그리고, FAT은 대단히 중요한 정보일 것이다. 데이터의 위치를 담고 있기 때문에 그래서, FAT은 한 카피만 두는게 아니라 중요한 정보라서 보통은, 디스크에다가 두 카피 이상을 저장을 하고 있다. 그러니까 Reliability 문제가 더 개선이 될 수 있는 것이다.
>
> - 512바이트도 충분히 활용 가능함
>
> 그래서, 이 'FAT 파일 시스템'은 Linked Allocation을 변형했지만, 단점을 모두 극복하는 방법이라는 것이다.

> 여기서 'UNIX의 파일 시스템', 'FAT 파일 시스템' 이렇게 두 가지만 예제로 말하고 있는데, 실제로 사용되는 파일 시스템들이 대단히 많다. 이러한 기본적인 방법을 상당히 개선해가지고 사용을 하고 있다. 그래서, 필요하면 현재 널리 사용되는 파일 시스템의 구조가 어떤지도 살펴보는 것이 도움이 될 것이다.

### Free-Space Management

<img src="https://user-images.githubusercontent.com/78403443/175221270-f5a2641d-c31e-4b8b-a540-62c617fac7fd.png" alt="image" style="zoom:50%;" />

> 위 그림과 같이 중간 중간 비어있는 블럭은 어떻게 관리하느냐? 에 대해서 설명
>
> 비어있는 블럭을 관리하는 방법도 몇 가지가 있다.

- ***<span style='color: #b1a5c8'><u>Bit map or bit vector</u></span>***

  > 비트맵을 두는 방법(혹은 비트 벡터 방법)

  <img src="https://user-images.githubusercontent.com/78403443/175220988-6399761b-09bc-49a2-b49b-cceddf3c0a55.png" alt="image" style="zoom:50%;" />

  > 각각의 블럭 별로 번호가 있으면, 그거를 UNIX같은 경우라면 Super block부분에다가 비트를 둬서, 첫번째 블럭이 사용중이냐, 비어있느냐를 1과 0으로 표시한다.
  >
  > 비트맵의 크기는 데이터 블럭 안에 있는 블럭의 개수 만큼으로 구성돼있다.
  >
  > 비트맵이 표시하는 바는
  >
  > - 만약, 값이 0이면, 비어있는 블럭을 나타내고,
  > - 1이면, 이미 파일에 할당된 블럭을 나타낸다.
  >
  > 파일 시스템이 어떤 파일이 새로 만들어지거나, 파일의 크기가 커지거나 하면, 비어있는 블럭 중에 하나를 할당을 해야될 것이고, 파일이 삭제되거나 그러면, 1로 표시돼있던 비트맵을 0으로 바꿔줘야할 것이다. 그런건 파일 시스템이 관리를 하고 있는 것임.

  - Bit map은 부가적인 공간을 필요로 함

    > 단점이라면, 단점일수도 있지만 그렇게 많은 공간이 필요하지는 않을 것이다. 블럭 하나당 1bit가 필요하기 때문에...

  - 연속적인 n개의 free block을 찾는데 효과적

    > 연속적인 빈 블럭을 찾는데 효과적. 
    >
    > 파일의 크기가 보통 블럭 하나로 구성되지는 않고, 블럭 10개로 구성된다고 하면, 가능하면 연속 할당을 쓰지는 않지만, 연속적인 빈 공간에 할당을 해주면 좋겠다는 것이다. 디스크 헤드가 이동할 필요가 없이 많은 양을 한꺼번에 읽어올 수가 있기 때문에...
    >
    > 그래서, 비트맵이라는 것은 쭉 비트맵을 스캔하게 되면, 연속적으로 0인 곳이 어딘지 찾기가 쉽기 때문에, 효과적.

- ***<span style='color: #b1a5c8'><u>Linked list</u></span>***

  > 링크드 리스트로 관리하는 방법

  - 모든 free block들을 링크로 연결 (free list)

    > 비어있는 블럭들을 모두 연결해놓는 것
    >
    > <img src="https://user-images.githubusercontent.com/78403443/175227625-2034fec1-d68d-4b03-bdbc-ad874aaa93b5.png" alt="image" style="zoom:50%;" />
    >
    > 회색들이 다 비어있는 블럭.
    >
    > 어차피 비어있는 블럭이기 때문에, 포인터를 가지고 다음에 비어있는 위치가 어딘지 저장할 수 있다.
    >
    > 'Linked list' 방법은 비어있는 블럭의 첫번째 위치만 우리가 포인터로 가지고 있고, 그 다음 비어있는 위치, 그 다음 위치는 실제 그 빈 블럭에 가면 다음 번 빈 블럭의 위치를 포인트하고 있는 이런 식으로 관리를 한다.

  - 연속적인 가용공간을 찾는 것은 쉽지 않다

    > 실제로 빈 위치들을 다 디스크 헤드가 seek를 해가지고, 어딘지 어딘지를 다 따라가봐서 연속적인거를 찾겠다고 하면 상당히 비효율적. 이론적으로 이런 방법도 있다는 정도... 실제로 쓰기가 쉽지 않을 것이다.

  - 공간의 낭비가 없다

  > 이 방법은 위에서 배웠던 Linked Allocation을 비슷하게 바꾼 것

- ***<span style='color: #b1a5c8'><u>Grouping</u></span>***

  > Indexed Allocation 같은 걸 빈 블럭을 관리하는데도 활용할 수가 있다.

  > 그룹핑을 하는 방법이 그 예

  <img src="https://user-images.githubusercontent.com/78403443/175221773-4c6062ea-b80c-4ef6-89a8-622446b01a9d.png" alt="image" style="zoom:50%;" align="right"/>

  - linked list 방법의 변형
  - 첫번째 free block이 n개의 pointer를 가짐
    - `n-1` pointer는 free data block을 가리킴
    - 마지막 pointer가 가리키는 block은 또 다시 `n` pointer를 가짐

  > 어차피 비어있으니까 우리가 아무렇게나 쓸 수가 있다.<br>처음의 비어있는 위치가 인덱스 역할을 해서, 
  >
  > - 첫번째 빈 위치에 가면, 비어있는 블럭들의 포인터들이 쭉 저장이 되있고, 비어있는 것들을 가리키고 있고, 
  > - 마지막 블럭에 가서 "더 비어있는 블럭들이 많이 있다" 그러면 또, 인덱스가 저장이 되있고,
  > - 그래서 인덱스의 앞에서부터 `n-1`개는 빈 블럭을 가리키고, 마지막 포인터는 또 다른 인덱스를 가리키고
  >
  > 이런식으로 해서 인덱스 형식으로 그룹핑을 해가지고, 빈 블럭의 위치를 가리키게 할 수가 있는 것.
  >
  > 비어있는 블럭을 한꺼번에 찾기에는 Linked list보다는 효율적이지만, 그래도 이것이 연속적인 빈 블럭을 찾기에 그렇게 썩 효과적이지는 않을 것이다. 

- ***<span style='color: #b1a5c8'><u>Counting</u></span>***

  > 그래서, 연속적인 빈 블럭을 찾기에 효과적인 방법으로 이 '카운팅' 을 하는 방법을 사용할 수가 있다.

  - 프로그램들이 종종 여러 개의 연속적인 block을 할당하고 반납한다는 성질에 착안
  - (first free block, # of contiguous free blocks)을 유지

  > 이 방법은 연속적인 빈 블럭을 표시하기 위해서,<br>빈 블럭의 첫번째 위치하고, 거기서부터 몇 개가 빈 블럭인지를 쌍으로 관리를 한다.
  >
  > Grouping같이 포인터가 빈 블럭을 가리키기만 하는게 아니라, 빈 블럭의 위치를 가리키고, 거기서부터 몇 개가 비어있다. 이런식으로 관리.
  >
  > 이런식으로 관리를 하게 되면, 예를 들어, 우리가 "연속적으로 5개 빈 블럭을 찾고 싶다"고 하면, 프리 블럭의 개수를 가리키는 필드가 5 이상이 되는 것을 찾으면 될 것이다.

**[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}**