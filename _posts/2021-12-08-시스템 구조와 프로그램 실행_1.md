---
title: "[운영체제] 시스템 구조와 프로그램 실행 (1)"
excerpt: "컴퓨터 시스템 구조와 프로그램 실행 (1)"
toc: true
toc_sticky: true
toc_label: "주요 목차"
header:
  teaser: /assets/images/operating-system.png

date: 2021-12-08T18:21:24+09:00

categories:
  - OS

tags:
  - Programming
  - 프로그래밍
  - 컴퓨터
  - Computer
  - Computer science
  - Computer engineering
  - 컴퓨터 공학
  - 컴퓨터 과학
  - Operating System
  - 운영체제
  - 시스템 구조
  - 프로그램 실행
  - System Structure
  - Program Execution
  - 컴퓨터 시스템 구조
  - Mode bit
  - Timer
  - Device Controller
  - 입출력(I/O)의 수행
  - 시스템콜
  - System Call
  - 인터럽트
  - Interrupt
last_modified_at: 2021-12-08T18:21:24+09:00
---

## 컴퓨터 시스템 구조와 프로그램 실행 (1)

<div class="notice">
    <h4>
        🔊 이화여자대학교 반효경 교수님의 2014년 1학기 운영체제 강의를 들으며 정리한 노트입니다.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;캡쳐한 이미지 출처 또한 반효경 교수님 강의 자료에 있음을 밝힙니다. 
    </h4>
</div>



### 컴퓨터 시스템 구조

컴퓨터 시스템의 하드웨어 구조를 간단히 요약한 그림 (아래)<br>![image](https://user-images.githubusercontent.com/78403443/145148404-46c9ecfc-2183-4d6c-8d91-2fc3f980d0e9.png)

- 컴퓨터 내부장치 : CPU, 메모리
- 컴퓨터 외부장치 : 그 외 나머지
- **I/O**는 Input, Output을 말한다.
  - **Input(입력)** : I/O 디바이스의 데이터가 컴퓨터 안으로 들어가는 것
  - **Output(출력)** : 데이터를 받아서 컴퓨터에서 처리를 한 결과를 다시 I/O 디바이스로 보내는 것
- CPU의 작업 공간이 메모리이기 때문에 CPU는 매 순간 정확하게는 매 클럭 싸이클마다 메모리에서 기계어를 하나씩 읽어서 실행을 하게 된다.

![image](https://user-images.githubusercontent.com/78403443/145150043-dd14dccb-f49d-4362-b8ce-8afdb569e442.png)

- 그리고 이러한 각각의 I/O 디바이스들은 그 디바이스를 전담하는 작은 CPU 같은 것들이 붙어있게 된다. 그것을 우리는 **device controller**라고 한다.
- 디스크에서 헤드가 어떻게 움직이고 어떤 데이터를 읽을지 디스크의 내부를 통제하는 것은 CPU의 역할이 아니고 디스크에 붙어있는 디스크 컨트롤러가 그런 작업을 하게 된다.
- 키보드 컨트롤러 등도 마찬가지... 키보드에 붙어있는건 키보드 컨트롤러 이런식으로 컨트롤러들이 각 I/O 디바이스마다 붙어있어서 그 디바이스를 전담하는 작은 CPU 역할을 한다고 보면 된다.
- 메인 CPU의 작업공간인 메인 메모리가 있듯이 이러한 디바이스 컨트롤러들도 그들의 작업공간이 필요하다. 그들의 작업공간이 위와 같이 각각 존재하는데 그것을 우리는 local buffer라고 부른다.
- CPU하고 I/O 디바이스는 처리하는 속도 차이가 굉장히 많이 난다. 그래서, 디스크를 CPU가 직접 관장하지 않고, device controller가 담당하고 있다.
- CPU의 운명이자 역할은 평생 메모리에서 Instruction을 하나씩 읽어서 실행하고, 그러고 또 그 다음 거 읽어서 실행하는 것이다.

![image](https://user-images.githubusercontent.com/78403443/145150907-2df6b5da-ec6e-44e9-84eb-6faeb39820e9.png)

CPU안에는...

- **registers**
  - 메모리보다 더 빠르면서 정보를 저장할 수 있는 작은 공간들
- **mode bit**
  - CPU에서 실행되는 것이 운영체제인지, 사용자 프로그램인지 구분해준다.
- **Interrupt line**
  - CPU는 항상 메모리에 있는 Instruction만 계속 실행을 하는데 키보드에서 어떤 입력이 들어오거나, 또는 디스크에서 뭘 읽어온다던지 디스크에 뭔가를 읽어오라고 요청을 했는데 디스크가 그 일을 다 끝냈다던지... 이런 것을 CPU가 어떻게 알까?
  - 그걸 전달하기 위해서 Interrupt line이 CPU에 붙어있는 것

CPU는 항상 메모리하고만 일한다. 그러나, 경우에 따라서는 키보드 입력을 받을 수도 있고, 프로그램이 실행되다가 디스크에서 어떤 파일을 읽어와서 다음 Intruction을 실행하는 그런 경우도 있을 것이다. (프로그램을 작성하다보면 항상 메모리만 가지고 작업을 하는 것이 아니라, 변수만 정의해서 작업을 하는게 아니라 키보드에서 뭘 읽어오고 화면에 뭔가를 출력하고 또, 디스크에서 뭔가를 읽어오거나 프로그램이 처리한 결과를 디스크에 쓰거나 이런식의 프로그램 구조가 되어 있기 때문에)<br>키보드 입력이나 화면 출력, 디스크 입출력 같은게 I/O 디바이스를 접근하는 Instruction들이 되겠다.

근데, CPU는 I/O 디바이스를 직접 접근을 하지 않고 계속 메모리에서 읽어서 즉, 메모리를 접근하는 Instruction만 실행하게 되어있다. 그러다가 디스크에서 뭘 읽어오라는 요청은 어떻게 보낼까? 

만약에 Instruction을 쭉 실행하다가 프로그램 A가 디스크에서 뭘 읽어와야된다 그러면 CPU가 직접 디스크를 접근하는게 아니라 CPU가 Disk controller한테 특정 데이터를 어딘가에서 읽어오라고 일을 시킨다. (일을 시키는 Instruction이 있다)<br>일을 시켜놓으면 디스크는 그 요청한 데이터를 Disk controller의 지시를 받아서 읽어온다. (읽어오는 작업은 굉장히 오래 걸릴 것이다) 그래서 디스크는 시킨 일을 하면서 읽어다가 자신의 local buffer에 집어넣게 된다.<br>그러는 동안 굉장히 빠른 CPU가 놀고 있으면 낭비가 될 것이다. 그래서 보통은 프로그램이 쭉 메모리 접근만 하면서 실행이 되다가, I/O를 하게 되면 그 I/O는 CPU가 직접하는게 아니라 I/O 컨트롤러한테 시키고 그런 다음에 CPU는 놀지 않고 또 메모리 접근을 계속 하면서 Instruction을 실행하는 것이다.

근데, 이 프로그램을 실행하다가 디스크에서 뭘 읽어오라고 했으면 읽어온 결과물을 보고 그 다음 Instruction을 실행하는 게 보통 프로그램의 구조...<br>예를 들면, CPU가 키보드에서 뭘 읽어오는 Instruction을 만나게 되면 Keyboard controller한테 사용자가 키보드를 두드려서 input이 들어오면 나한테 알려달라고 얘기해놓고,  CPU는 키보드에 입력이 들어오는지 안들어오는지는 (오래 걸리는 작업이기 때문에) 개의치 않고, 본인이 할 수 있는 일을 계속 실행하는 것이다.<br>그러다가 프로그램이 더이상 I/O 들어오는 데이터가 뭔지를 모르고서는 더 이상 실행이 안되겠다라고 하면 CPU가 (당장 CPU만 주면 나는 메모리하고만 접근하면서 Instruction을 실행할 수 있다고 하는) 다른 프로그램한테 넘어간다.

즉, CPU는 되게 빠른 일꾼인데 그 빠른 속도를 이용해서 계속 쉬지않고 일만 하는 것...<br>그래서 프로그램 여러개가 동시에 실행될 때 CPU는 아주 짧은 시간 간격으로 왔다갔다하면서 처리하기 때문에 실제 사용자 입장에서 보면 굉장히 Interactive하게, 빠르게 CPU가 응답해주는 것으로 보이는 것이다.

여기서 한 가지 문제는, 만약에 for나 while문을 돌리면서 무한 루프를 도는 프로그램을 만들었는데 이 프로그램한테 CPU가 한번 넘어가면 프로그램이 종료되지도 않고, I/O를 하지도 않고 계속 CPU만 쓸 것이다. 그렇게 되면 CPU가 다른 프로그램한테 넘어가지 못해서 Time Sharing을 구현할 수 없을 것이다. 그래서, 컴퓨터 안에는 timer라는 하드웨어를 두고 있다.

- **timer**
  - 역할
    - 특정 프로그램이 CPU를 독점하는 것을 막기 위한 것
  - 컴퓨터 켰을 때 처음에는 운영체제가 CPU를 가지고 있다가, 여러 사용자 프로그램이 실행이 되면 Timer에다가 어떤 값을 셋팅(보통 1초보다 짧게, 수십 ms 정도) 한 다음에 사용자 프로그램에게 CPU를 넘겨준다.
  - 그럼 사용자 프로그램은 독점적으로 CPU를 계속 쓸 수 있는게 아니라 timer에 할당된 시간 만큼 CPU를 사용
  - CPU는 그 시간 동안 자기 Instruction을 실행하고, 실행하다가 셋팅 된 시간이 다 되면 timer가 CPU한테 Interrupt를 건다.(시간이 끝났다고 알려준다)
  - CPU는 매번 Instruction을 하나씩 실행하다가 하나의 Instruction이 끝나고 나면, Interrupt line을 체크한다. 
  - 즉, CPU는 계속 Instruction만 실행하는 것은 아니고 Instruction 실행하고, Interrupt line 체크. Interrupt 들어온게 없으면 다음 Instruction 실행하고, 끝났으면 Interrupt 들어온게 있는지 Interrupt line 체크... 이 작업이 CPU가 반복하는 작업
  - 그래서 만약에 timer가 Interrupt를 걸어왔으면 CPU는 하던 일을 잠시 멈추고, CPU의 제어권이 사용자 프로그램으로부터 운영체제한테 자동으로 넘어가게 되어있다.<br>즉, 운영체제가 사용자 프로그램한테 CPU를 줄 때는 자유롭게 주지만 한번 넘어가면 뺏을 수는 없는 것<br>왜 못뺏느냐? 운영체제가 CPU를 뺏으려면 본인이 CPU를 가지고 있으면서 뭔가 Instruction을 실행을 해야 뺏든지 말든지 하니까(운영체제 본인이 사용자 프로그램한테 CPU를 넘겨준 다음에는 사용자 프로그램이 CPU를 가지고 마음껏 쓰는 것임. 그러면, 운영체제가 아무리 똑똑하게 짜여져 있다고 하더라도 뺏을 방법이 없다.)
  - 그래서, 추가적인 timer라는 하드웨어를 둬가지고 이 친구가 timer Interrupt를 걸어주면 CPU제어권이 자동으로 사용자 프로그램으로부터 운영체제로 넘어오도록 그렇게 만든 것.
  - 그렇게 운영체제가 CPU를 얻게 되면? 다음 프로그램한테 timer에다가 값을 셋팅해서 CPU를 넘겨준다. 그리고 만료가 되면 timer interrupt가 들어오고 CPU제어권이 OS로 넘어간다.<br>위 이미지에선 프로그램이 A, B 두 개 밖에 없으나 프로그램이 N개가 있다고 하면 CPU가 N개의 프로그램한테 하나씩 넘어갔다가 제일 앞 프로그램으로 되돌아오고 이런식으로 CPU가 넘어감...
  - 프로그램 본인은 계속 CPU를 쓰고 싶은데 여럿이서 분할해서 써야 되니까 CPU의 time sharing... 나눠서 쓰는 것을 구현하기 위해서 timer라는 것을 두고 있는 것.<br>그런데, 사실 본인이 계속 CPU를 쓰는게 아니다. 제대로 된 프로그램이라면 메모리하고만 작업을 하는게 아니라 가끔씩 I/O 디바이스에서 읽어오고 출력하는 경우가 반드시 있을 것이다.
  - 사용자 프로그램은 본인이 직접 I/O 장치를 접근할 수 없다. I/O 장치를 접근하는 모든 Instruction은 운영체제를 통해서만 할 수 있도록 막아놨다. (이유: 보안)<br>그렇게 때문에, 프로그램이 디스크나 키보드에서 뭘 읽어와야 된다거나, 화면에 출력하는 등의 I/O 작업을 해야되면 스스로 프로그램이 운영체제한테 CPU를 넘겨준다.<br>그러면, 운영체제가 해당하는 작업을 I/O Controller한테 시킨다.<br>시키고 나서 I/O 작업이 오래 걸리니까 운영체제는 다른 프로그램한테 CPU를 넘겨주게 된다.
  - I/O 작업을 요청했던 프로그램은 언제 다시 CPU를 얻게 되느냐?<br>I/O Controller가 요청한 작업이 끝나서 (예를 들어, 사용자가 키보드 입력을 두드려서 키보드 입력된 데이터가 자신의 buffer에 들어오면 Keyboard Controller가) CPU한테 Interrupt를 걸면 (어떤 다른 프로그램에서 CPU가 실행이 되고 있었겠지만 Interrupt가 들어오면) 기본적으로 CPU제어권은 운영체제한테 자동으로 넘어가게 된다.<br>그러면 운영체제가 지금 Interrupt가 왜 들어왔는지 살펴본 후, (아까 어떤 프로그램이 요청했던 키보드 입력이 들어온거라면) 입력된 키보드 값을 아까 키보드 입력 요청한 프로그램의 메모리 공간에다가 copy를 해주고, 그런 다음에 보통은 방금 전에 CPU를 쓰다가 Interrupt를 당한 다른 프로그램에 (timer에서 한정된 시간이 아직 남아있다고 하면) CPU를 주어 CPU를 더 쓰게 하고, 할당된 시간이 끝나고 언젠가는 키보드 입력이 들어와서 준비가 완료된 프로그램한테 CPU를 주게 된다.
  - 이런식으로 돌아간다.

---

#### Mode bit

- 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치 필요
- Mode bit을 통해 하드웨어적으로 두 가지 모드의 operation 지원
  - Mode bit
    - 1 사용자 모드: 사용자 프로그램 수행
    - 0 모니터 모드(= 커널 모드, 시스템 모드): OS 코드 수행, (운영체제가 CPU에서 실행중인 것)
  - 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 '특권명령'으로 규정
  - Interrupt나 Exception 발생시 하드웨어가 mode bit을 0으로 바꿈
  - 사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 셋팅
  - ![image](https://user-images.githubusercontent.com/78403443/145164083-989b488b-1cc8-4011-95dd-ab3be7da6733.png)

#### Timer

- 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킴
- 타이머는 매 클럭 틱 때마다 1씩 감소
- 타이머 값이 0이 되면 타이머 인터럽트 발생
- CPU를 특정 프로그램이 독점하는 것으로부터 보호
- 타이머는 time sharing을 구현하기 위해 널리 이용됨
- 타이머는 현재 시간을 계산하기 위해서도 사용

#### Device Controller

- I/O device controller
  - 해당 I/O 장치유형을 관리하는 일종의 작은 CPU
  - 제어 정보를 위해 control register, status register를 가짐
  - local buffer를 가짐 (일종의 data register, 데이터 저장하는...)
- I/O는 실제 device와 local buffer 사이에서 일어남
- Device controller는 I/O가 끝났을 경우 interrupt로 CPU에 그 사실을 알림
- device driver(장치구동기)
  - OS 코드 중 각 장치별 처리 루틴 → software
- device controller(장치제어기) 
  - 각 장치를 통제하는 일종의 작은 CPU → hardware

사용자 프로그램의 결과를 화면에 출력하기 위해서는,<br>실제 프로그램에 있는 데이터는 모니터의 local buffer에 담는거고, 화면에 출력을 하라는 지시는 control register(제어 레지스터)를 통해서 한다는 얘기이다.

마찬가지로 사용자 프로그램에 있는 어떤 데이터를 파일에다 저장하고 싶다면,<br>그 데이터 자체는 디스크 쪽 local buffer에 넣고, 파일에 저장하라는 명령은 control register(제어 레지스터)를 통해서 CPU가 I/O Controller에게 전달을 하게 되는 것이다.

![image](https://user-images.githubusercontent.com/78403443/145150907-2df6b5da-ec6e-44e9-84eb-6faeb39820e9.png)

위 이미지를 보면 메모리도 하나의 디바이스이기 때문에 메모리를 전담하는 컨트롤러도 있다. (memory controller) 다른 디바이스와 마찬가지로 붙어있고...

메인 메모리는 CPU만 접근하고, I/O 디바이스들은 자기 자신들의 local buffer가 존재하기 때문에 buffer에다가 데이터를 받아서 일을 하고 buffer에 쌓이게 되면 CPU가 buffer에 있는 내용을 읽어서 자신의 작업영역인 메모리에 복사를 한다.<br>CPU는 메모리 접근도 할 수 있고 local buffer접근도 할 수 있게 되어있고, 작은 CPU(device controller)들은 자기 자신의 local buffer만 접근할 수 있게 이렇게 정의가 되어 있는 것이다.

근데 그렇게 하다보니까 CPU가 너무 Interrupt를 많이 당함...<br>그 얘기는 처리 속도가 굉장히 빠른 CPU라는 장치가 그다지 효율적이지 않게 동작을 한다는 것이다. 그래서 DMA라는 컨트롤러를 하나 더 두고 있다.

#### DMA Controller

- Direct Memory Access Controller, 직접 메모리를 접근할 수 있는 컨트롤러
- 원래는 메모리를 접근할 수 있는 장치는 CPU뿐이었는데, DMA Controller를 두게 되면 CPU도, DMA도 메모리를 접근할 수 있게 되어있다.
- CPU와 DMA 둘이서 만약에 특정 메모리 영역을 동시에 접근하거나 이럴 때 문제가 생길 수 있어서 memory controller가 그런 동시 접근하는 것을 중재, 조율, 교통정리하는 역할을 해준다.
- 그럼 DMA는 왜 달아놨는가?<br>I/O 디바이스들이 너무 자주 Interrupt를 거니까 CPU가 방해를 너무 많이 받는다. 즉, 중간중간에 I/O 디바이스들이 뭔가 작업이 들어왔을 때 그거를 CPU한테 Interrupt를 걸어서 CPU가 local buffer에 있는 내용을 메인 메모리에 copy하게 하는 것이 너무 오버헤드가 크다는 것이다.<br>그 문제를 해결 하기 위해서 CPU는 계속 자기 일을 하고 있고, 중간중간에 local buffer에 들어오는 내용이 작업이 끝났으면 DMA가 직접 local buffer에 있는 내용을 메모리로 복사하는 일을 하고, 그 작업이 다 끝났으면 CPU한테 Interrupt를 한번만 걸어서 작업이 완료되었음을 알린다.
- 이와 같이, CPU는 중간에 Interrupt 당하는 빈도가 줄어들어서 자신의 빠른 장치를 좀 더 효율적으로 쓸 수 있게 DMA가 역할해주는 것이다.

### 입출력(I/O)의 수행

- 모든 입출력 명령은 특권 명령
- 사용자 프로그램은 어떻게 I/O 하는가?
  - 시스템콜(System call)
    - 사용자 프로그램은 운영체제에게 I/O 요청
  - trap을 사용하여 인터럽트 벡터의 특정 위치로 이동
  - 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
  - 올바른 I/O 요청인지 확인 후 I/O 수행
  - I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김

### 인터럽트 (Interrupt)

- 인터럽트 당한 시점의 레지스터와 program counter를 save한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다
- Interrupt (넓은 의미)
  - Interrupt (하드웨어 인터럽트): 하드웨어가 발생시킨 인터럽트
  - Trap (소프트웨어 인터럽트)
    - Exception: 프로그램이 오류를 범한 경우
    - System call: 프로그램이 커널 함수를 호출하는 경우
- 인터럽트 관련 용어
  - 인터럽트 벡터
    - 해당 인터럽트의 처리 루틴 주소를 가지고 있음<br>(인터럽트의 종류가 여러가지 있고, 그 인터럽트 종류마다 해야될 일들이 다르다. 그러면 각각의 인터럽트 종류마다 무슨 일을 해야되는지가 운영체제 코드에 다 정의가 되어있다.)
    - (인터럽트가 들어왔을 때 예를 들어, 1번 인터럽트가 들어왔을 때는 어떤 함수로 가야되고, 2번 인터럽트가 들어왔을 때는 어떤 함수로 들어가야되는지 그런거를 표시를 해줘야 될 것이다.)
    - 그런 표시를 인터럽트 벡터에다가 표시해주고 있는 것이다.<br>(각 인터럽트 종류마다 그 인터럽트가 생겼을 때 어디 있는 함수를 실행해야되는지 그 함수의 주소들을 쭉 정의해놓은 일종의 테이블 같은 것)
  - (그렇게 각 인터럽트마다 처리해야될 실제 코드를 인터럽트 처리 루틴이라고 부른다.)
  - 인터럽트 처리 루틴<br>(= Interrupt Service Routine, 인터럽트 핸들러)
    - 해당 인터럽트를 처리하는 커널 함수
    - 실제로 인터럽트를 처리하는 부분

![image](https://user-images.githubusercontent.com/78403443/145177815-141d96b9-8eec-4033-9e8e-21eb2fa1644e.png)

I/O 요청을 할 때는 소프트웨어 인터럽트를 통해서 요청, I/O가 다 끝났으면 하드웨어 인터럽트를 통해서 끝났다는 것을 알려줌... 그래서 두 가지 다 필요한 것이다!

![image](https://user-images.githubusercontent.com/78403443/145177115-16e050b0-960a-4434-b4f3-5c261588627a.png)

아까 말했듯이 CPU를 특정 프로그램이 독점하는 것을 막기 위해서 timer Interrupt 라는 것을 사용하고 있고,

![image](https://user-images.githubusercontent.com/78403443/145177655-a02527b5-0187-4292-9831-aa4d0f56863c.png)

그 다음에 요청한 I/O가 다 끝났다는 것을 알려주기 위해서(또는 예를 들어, 키보드에 어떤 입력이 들어왔다는 것을 알려주기 위해서) 그런 것을 전달하는 것은 I/O Controller가 Interrupt를 걸어서 알려주게 되는 것이다.

그래서 현대의 운영체제는 인터럽트에 의해서 구동된다. 이런 말을 쓴다.<br>즉, 운영체제는 CPU를 사용할 일이 없고, 인터럽트가 들어올 때만 CPU가 운영체제한테 넘어가는 것이지 그렇지 않으면 운영체제는 항상 사용자 프로그램이 쓰고 있게 되는 것이다.

### 시스템콜 (System Call)

- 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것

![image](https://user-images.githubusercontent.com/78403443/145178847-90c62a18-1581-4ec6-8828-a4baa3e0a6aa.png)

사용자 프로그램이 운영체제한테 뭔가 부탁할 때 시스템콜(System Call)을 통해서 부탁을 하게 되는 것이다. (꼭 I/O만 시스템콜에 의해서 되는건 아님)

즉, 사용자 프로그램이 운영체제 코드를 직접 수행하는 것이 불가능하기 때문에 운영체제에 있는 함수 호출을 할 때는 사용자 프로그램이 Interrupt line을 셋팅하고, 그러면 CPU 제어권이 운영체제한테 넘어가기 때문에 부탁한 일을 운영체제가 할 수 있게 되는 것이다.

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}